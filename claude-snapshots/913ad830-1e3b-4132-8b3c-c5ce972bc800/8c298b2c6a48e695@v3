#pragma once

#include <juce_gui_basics/juce_gui_basics.h>

/**
 * Custom LookAndFeel for Glowing Activity Knobs
 *
 * Creates rotary sliders with an inner glow effect that radiates
 * from center to edge when the associated DSP module is active.
 * The glow intensity reflects real-time processing activity.
 */
class GlowingKnobLookAndFeel : public juce::LookAndFeel_V4
{
public:
    GlowingKnobLookAndFeel()
    {
        // Default glow color (can be customized per knob)
        setGlowColour (juce::Colours::cyan);
    }

    /** Set the glow color for this knob */
    void setGlowColour (juce::Colour colour)
    {
        glowColour = colour;
    }

    /** Set the glow intensity (0.0 = off, 1.0 = full) */
    void setGlowIntensity (float intensity)
    {
        glowIntensity = juce::jlimit (0.0f, 1.0f, intensity);
    }

    /** Get current glow intensity */
    float getGlowIntensity() const { return glowIntensity; }

    //==============================================================================
    void drawRotarySlider (juce::Graphics& g, int x, int y, int width, int height,
                          float sliderPos, float rotaryStartAngle, float rotaryEndAngle,
                          juce::Slider& slider) override
    {
        auto bounds = juce::Rectangle<int> (x, y, width, height).toFloat().reduced (10);
        auto radius = juce::jmin (bounds.getWidth(), bounds.getHeight()) / 2.0f;
        auto toAngle = rotaryStartAngle + sliderPos * (rotaryEndAngle - rotaryStartAngle);
        auto centerX = bounds.getCentreX();
        auto centerY = bounds.getCentreY();

        // === PHILIPS GA 312 VINTAGE STYLE ===

        // 1. Outer chrome ring (metallic effect with gradient)
        juce::ColourGradient chromeGradient (
            juce::Colour (0xffe0e0e0), centerX, centerY - radius,  // Light silver top
            juce::Colour (0xff808080), centerX, centerY + radius,  // Darker bottom
            false);
        chromeGradient.addColour (0.3, juce::Colour (0xfff5f5f5)); // Highlight
        chromeGradient.addColour (0.7, juce::Colour (0xff606060)); // Shadow
        g.setGradientFill (chromeGradient);
        g.fillEllipse (centerX - radius, centerY - radius, radius * 2.0f, radius * 2.0f);

        // 2. Outer edge shadow for 3D depth
        g.setColour (juce::Colours::black.withAlpha (0.3f));
        g.drawEllipse (centerX - radius, centerY - radius, radius * 2.0f, radius * 2.0f, 1.5f);

        // 3. Inner black/dark area
        auto innerRadius = radius * 0.75f;
        g.setColour (juce::Colour (0xff1a1a1a));
        g.fillEllipse (centerX - innerRadius, centerY - innerRadius,
                      innerRadius * 2.0f, innerRadius * 2.0f);

        // 4. Inner glow ring (translucent - vintage style)
        if (glowIntensity > 0.01f)
        {
            // Create smooth radial glow from center outward
            auto glowRadius = innerRadius * 0.85f;

            for (int i = 0; i < 16; ++i)
            {
                float layerProgress = static_cast<float> (i) / 16.0f;
                float currentRadius = glowRadius * (0.3f + layerProgress * 0.7f);
                float alpha = glowIntensity * (1.0f - layerProgress) * 0.2f;

                g.setColour (glowColour.withAlpha (alpha));
                g.fillEllipse (centerX - currentRadius, centerY - currentRadius,
                              currentRadius * 2.0f, currentRadius * 2.0f);
            }

            // Bright inner glow core
            auto coreRadius = glowRadius * 0.4f;
            g.setColour (glowColour.withAlpha (glowIntensity * 0.6f));
            g.fillEllipse (centerX - coreRadius, centerY - coreRadius,
                          coreRadius * 2.0f, coreRadius * 2.0f);
        }

        // 5. Subtle inner ring highlight (vintage translucent effect)
        auto ringRadius = innerRadius * 0.9f;
        juce::ColourGradient ringGradient (
            juce::Colours::white.withAlpha (0.1f), centerX, centerY - ringRadius,
            juce::Colours::transparentBlack, centerX, centerY + ringRadius,
            false);
        g.setGradientFill (ringGradient);
        g.drawEllipse (centerX - ringRadius, centerY - ringRadius,
                      ringRadius * 2.0f, ringRadius * 2.0f, 2.0f);

        // 6. White pointer line (Philips style - thin and precise)
        juce::Path pointer;
        auto pointerLength = innerRadius * 0.7f;
        auto pointerWidth = 2.5f;

        // Create pointer from center to edge
        pointer.startNewSubPath (0, -pointerLength * 0.3f);
        pointer.lineTo (0, -pointerLength);

        // Apply rotation and translation
        pointer.applyTransform (juce::AffineTransform::rotation (toAngle)
                                                       .translated (centerX, centerY));

        // Draw pointer with glow when active
        if (glowIntensity > 0.4f)
        {
            // Glow halo around pointer
            g.setColour (glowColour.withAlpha (glowIntensity * 0.5f));
            g.strokePath (pointer, juce::PathStrokeType (pointerWidth + 2.0f,
                                                         juce::PathStrokeType::curved,
                                                         juce::PathStrokeType::rounded));
        }

        // Main pointer (white)
        g.setColour (juce::Colours::white.withAlpha (0.95f));
        g.strokePath (pointer, juce::PathStrokeType (pointerWidth,
                                                     juce::PathStrokeType::curved,
                                                     juce::PathStrokeType::rounded));

        // 7. Center dot (vintage style)
        auto dotRadius = 3.0f;

        // Chrome center dot
        juce::ColourGradient dotGradient (
            juce::Colour (0xfff0f0f0), centerX - dotRadius * 0.5f, centerY - dotRadius * 0.5f,
            juce::Colour (0xffa0a0a0), centerX + dotRadius * 0.5f, centerY + dotRadius * 0.5f,
            true);
        g.setGradientFill (dotGradient);
        g.fillEllipse (centerX - dotRadius, centerY - dotRadius,
                      dotRadius * 2.0f, dotRadius * 2.0f);

        // Highlight on center dot
        g.setColour (juce::Colours::white.withAlpha (0.6f));
        g.fillEllipse (centerX - dotRadius * 0.5f, centerY - dotRadius * 0.7f,
                      dotRadius, dotRadius * 0.8f);
    }

private:
    juce::Colour glowColour;
    float glowIntensity = 0.0f;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (GlowingKnobLookAndFeel)
};
