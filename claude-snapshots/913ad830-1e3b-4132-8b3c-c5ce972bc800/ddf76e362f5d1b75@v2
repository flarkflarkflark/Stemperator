#pragma once

#include <juce_dsp/juce_dsp.h>
#include <juce_audio_basics/juce_audio_basics.h>

/**
 * Click and Pop Removal Processor
 *
 * Implements multiple click removal strategies:
 * 1. Cubic spline interpolation for larger clicks
 * 2. Crossfade/envelope smoothing for smaller pops
 * 3. Automatic detection with adjustable sensitivity
 *
 * Based on Wave Corrector's approach combined with manual crossfade technique.
 */
class ClickRemoval
{
public:
    //==============================================================================
    /** Information about a detected or manual click correction */
    struct ClickInfo
    {
        int64_t position = 0;       // Sample position in stream
        int width = 0;              // Width in samples
        float magnitude = 0.0f;     // Detected magnitude
        bool isManual = false;      // User-inserted correction
    };

    ClickRemoval() = default;

    //==============================================================================
    /** Initialize with audio specifications */
    void prepare (const juce::dsp::ProcessSpec& spec)
    {
        sampleRate = spec.sampleRate;
        numChannels = spec.numChannels;

        reset();
    }

    /** Reset internal state */
    void reset()
    {
        detectedClicks.clear();
    }

    /** Process audio block */
    void process (juce::dsp::ProcessContextReplacing<float>& context)
    {
        auto& inputBlock = context.getInputBlock();
        auto& outputBlock = context.getOutputBlock();

        // TODO: Implement click detection and removal
        // For now, just pass through
        outputBlock.copyFrom (inputBlock);

        if (sensitivity > 0.0f)
        {
            detectAndRemoveClicks (outputBlock);
        }
    }

    //==============================================================================
    /** Set click detection sensitivity (0-100) */
    void setSensitivity (float newSensitivity)
    {
        sensitivity = juce::jlimit (0.0f, 100.0f, newSensitivity);
    }

    /** Set maximum width for click correction in samples */
    void setMaxWidth (int samples)
    {
        maxClickWidth = samples;
    }

    /** Set removal method */
    enum RemovalMethod
    {
        SplineInterpolation,    // Cubic spline for large clicks
        CrossfadeSmoothing,     // Fade in/out for small pops (Reaper-style)
        Automatic               // Choose based on click size
    };

    void setRemovalMethod (RemovalMethod method)
    {
        removalMethod = method;
    }

    //==============================================================================
    /** Manually mark a click for removal (for GUI/standalone mode) */
    void addManualClick (int64_t samplePosition, int width)
    {
        ClickInfo click;
        click.position = samplePosition;
        click.width = width;
        click.isManual = true;
        detectedClicks.push_back (click);
    }

    /** Get list of detected clicks (for GUI display) */
    const std::vector<ClickInfo>& getDetectedClicks() const
    {
        return detectedClicks;
    }

private:

    //==============================================================================
    void detectAndRemoveClicks (juce::dsp::AudioBlock<float>& block)
    {
        // Improved click detection algorithm based on Wave Corrector approach
        // Uses first and second derivative analysis with adaptive thresholding

        for (size_t channel = 0; channel < block.getNumChannels(); ++channel)
        {
            auto* channelData = block.getChannelPointer (channel);
            auto numSamples = block.getNumSamples();

            if (numSamples < 10)
                continue;

            // Calculate RMS level for adaptive threshold
            float rmsLevel = calculateRMS (channelData, numSamples);
            float adaptiveThreshold = calculateThreshold (rmsLevel);

            // Scan for clicks using derivative analysis
            for (size_t i = 4; i < numSamples - 4; ++i)
            {
                // Calculate first derivative (rate of change)
                float firstDeriv = std::abs (channelData[i] - channelData[i - 1]);

                // Calculate second derivative (acceleration)
                float secondDeriv = std::abs ((channelData[i] - channelData[i - 1]) -
                                              (channelData[i - 1] - channelData[i - 2]));

                // Click detection: sharp discontinuity in second derivative
                if (secondDeriv > adaptiveThreshold)
                {
                    // Check if this is not part of periodic signal (music)
                    if (!isPeriodic (channelData, static_cast<int> (i), numSamples))
                    {
                        // Estimate click width by finding where signal stabilizes
                        int clickWidth = estimateClickWidth (channelData, static_cast<int> (i), numSamples);

                        if (clickWidth > 0 && clickWidth <= maxClickWidth)
                        {
                            // Apply removal
                            removeClickAt (channelData, static_cast<int> (i), clickWidth, numSamples);

                            // Skip ahead to avoid re-detecting same click
                            i += clickWidth;
                        }
                    }
                }
            }
        }
    }

    float calculateRMS (const float* data, size_t numSamples)
    {
        float sum = 0.0f;
        for (size_t i = 0; i < numSamples; ++i)
            sum += data[i] * data[i];
        return std::sqrt (sum / static_cast<float> (numSamples));
    }

    float calculateThreshold (float rmsLevel)
    {
        // Adaptive threshold based on signal level and sensitivity
        // Higher sensitivity = lower threshold
        float baseThreshold = 0.5f;
        float sensitivityFactor = (100.0f - sensitivity) / 100.0f;
        return baseThreshold * sensitivityFactor * juce::jmax (0.01f, rmsLevel);
    }

    bool isPeriodic (const float* data, int position, size_t numSamples)
    {
        // Simple periodicity check using short-range autocorrelation
        // Helps filter out musical transients

        const int checkRange = 32; // Check nearby samples
        if (position < checkRange || position + checkRange >= static_cast<int> (numSamples))
            return false;

        float autocorr = 0.0f;
        for (int offset = 1; offset <= checkRange; ++offset)
        {
            autocorr += std::abs (data[position] - data[position + offset]);
        }

        // If nearby samples are very similar, likely periodic
        return (autocorr / checkRange) < 0.05f;
    }

    int estimateClickWidth (const float* data, int position, size_t numSamples)
    {
        // Estimate how many samples are affected by the click
        // Look forward and backward for stabilization

        int maxSearch = juce::jmin (maxClickWidth / 2, 64);
        int start = juce::jmax (0, position - maxSearch);
        int end = juce::jmin (static_cast<int> (numSamples) - 1, position + maxSearch);

        float centerValue = data[position];
        float threshold = 0.1f;

        // Find extent of discontinuity
        int widthBefore = 0;
        for (int i = position - 1; i >= start; --i)
        {
            if (std::abs (data[i] - centerValue) < threshold)
                break;
            widthBefore++;
        }

        int widthAfter = 0;
        for (int i = position + 1; i <= end; ++i)
        {
            if (std::abs (data[i] - centerValue) < threshold)
                break;
            widthAfter++;
        }

        return widthBefore + widthAfter + 1;
    }

    void removeClickAt (float* channelData, int position, int clickWidth, size_t numSamples)
    {
        // Choose removal method based on click size
        RemovalMethod method = removalMethod;
        if (method == Automatic)
        {
            // Use spline for wider clicks, crossfade for narrow pops
            method = (clickWidth > 32) ? SplineInterpolation : CrossfadeSmoothing;
        }

        if (method == CrossfadeSmoothing)
        {
            applyCrossfadeSmoothing (channelData, position, clickWidth, numSamples);
        }
        else if (method == SplineInterpolation)
        {
            applyCubicSpline (channelData, position, clickWidth, numSamples);
        }
    }

    //==============================================================================
    /** Apply crossfade smoothing (Reaper-style manual technique) */
    void applyCrossfadeSmoothing (float* channelData, int position, int clickWidth, size_t numSamples)
    {
        // Create a short fade around the click
        int fadeLength = juce::jmax (clickWidth / 2, 16);
        int fadeStart = juce::jmax (0, position - fadeLength);
        int fadeEnd = juce::jmin (static_cast<int> (numSamples) - 1, position + fadeLength);

        if (fadeEnd <= fadeStart + 1)
            return;

        // Get clean values at boundaries
        float startValue = channelData[fadeStart];
        float endValue = channelData[fadeEnd];

        // Apply smooth crossfade using cosine curve
        int fadeRange = fadeEnd - fadeStart;
        for (int i = fadeStart; i <= fadeEnd; ++i)
        {
            float phase = static_cast<float> (i - fadeStart) / static_cast<float> (fadeRange);
            // Cosine interpolation for smooth curve
            float weight = 0.5f - 0.5f * std::cos (phase * juce::MathConstants<float>::pi);
            channelData[i] = startValue + (endValue - startValue) * weight;
        }
    }

    //==============================================================================
    /** Apply cubic spline interpolation (Wave Corrector approach) */
    void applyCubicSpline (float* channelData, int position, int clickWidth, size_t numSamples)
    {
        // Use Catmull-Rom spline for smooth interpolation
        // We need 4 control points: 2 before and 2 after the damaged region

        int interpolateLength = juce::jmax (clickWidth, 8);
        int start = juce::jmax (0, position - interpolateLength / 2);
        int end = juce::jmin (static_cast<int> (numSamples) - 1, position + interpolateLength / 2);

        if (end <= start + 1)
            return;

        // Get control points from clean regions
        int margin = 4; // samples before/after to use as control points
        int p0Idx = juce::jmax (0, start - margin);
        int p1Idx = start;
        int p2Idx = end;
        int p3Idx = juce::jmin (static_cast<int> (numSamples) - 1, end + margin);

        // Average a few samples for stable control points
        float p0 = averageSamples (channelData, p0Idx, juce::jmin (margin, p1Idx - p0Idx));
        float p1 = channelData[p1Idx];
        float p2 = channelData[p2Idx];
        float p3 = averageSamples (channelData, p2Idx + 1, juce::jmin (margin, p3Idx - p2Idx));

        // Apply Catmull-Rom spline interpolation
        int range = end - start;
        for (int i = start; i <= end; ++i)
        {
            float t = static_cast<float> (i - start) / static_cast<float> (range);
            channelData[i] = catmullRomInterpolate (p0, p1, p2, p3, t);
        }
    }

    /** Catmull-Rom spline interpolation */
    float catmullRomInterpolate (float p0, float p1, float p2, float p3, float t)
    {
        float t2 = t * t;
        float t3 = t2 * t;

        // Catmull-Rom spline formula
        float v0 = -0.5f * p0 + 1.5f * p1 - 1.5f * p2 + 0.5f * p3;
        float v1 = p0 - 2.5f * p1 + 2.0f * p2 - 0.5f * p3;
        float v2 = -0.5f * p0 + 0.5f * p2;
        float v3 = p1;

        return v0 * t3 + v1 * t2 + v2 * t + v3;
    }

    /** Average a few samples for stable control point */
    float averageSamples (const float* data, int startIdx, int count)
    {
        if (count <= 0)
            return data[startIdx];

        float sum = 0.0f;
        for (int i = 0; i < count; ++i)
            sum += data[startIdx + i];

        return sum / static_cast<float> (count);
    }

    //==============================================================================
    double sampleRate = 44100.0;
    juce::uint32 numChannels = 2;
    float sensitivity = 50.0f;
    int maxClickWidth = 512;
    RemovalMethod removalMethod = Automatic;

    std::vector<ClickInfo> detectedClicks;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ClickRemoval)
};
