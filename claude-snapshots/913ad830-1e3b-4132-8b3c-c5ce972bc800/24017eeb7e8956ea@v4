#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
AudioRestorationEditor::AudioRestorationEditor (AudioRestorationProcessor& p)
    : AudioProcessorEditor (&p), audioProcessor (p)
{
    // Set editor size - fully scalable and resizable
    setSize (baseWidth, baseHeight);
    setResizable (true, true);
    setResizeLimits (500, 400, 2560, 1440); // Min 500x400, max supports 1440p displays

    //==============================================================================
    // UI Scale Selector
    scaleLabel.setText ("UI Scale:", juce::dontSendNotification);
    scaleLabel.setJustificationType (juce::Justification::centredRight);
    addAndMakeVisible (scaleLabel);

    scaleSelector.addItem ("25%", 1);
    scaleSelector.addItem ("50%", 2);
    scaleSelector.addItem ("75%", 3);
    scaleSelector.addItem ("100%", 4);
    scaleSelector.addItem ("125%", 5);
    scaleSelector.addItem ("150%", 6);
    scaleSelector.addItem ("200%", 7);
    scaleSelector.addItem ("300%", 8);
    scaleSelector.addItem ("400%", 9);
    scaleSelector.setSelectedId (4); // Default 100%
    addAndMakeVisible (scaleSelector);

    scaleSelector.onChange = [this]
    {
        const float scaleValues[] = {0.25f, 0.5f, 0.75f, 1.0f, 1.25f, 1.5f, 2.0f, 3.0f, 4.0f};
        int selectedIndex = scaleSelector.getSelectedId() - 1;
        if (selectedIndex >= 0 && selectedIndex < 9)
        {
            setScaleFactor (scaleValues[selectedIndex]);
        }
    };

    scaleAttachment = std::make_unique<ComboBoxAttachment> (
        audioProcessor.getParameters(), "uiScale", scaleSelector);

    //==============================================================================
    // Global Controls - Difference Mode
    differenceModeButton.setButtonText ("Listen to Difference (Hear what's being removed)");
    differenceModeButton.setColour (juce::ToggleButton::textColourId, juce::Colours::orange);
    addAndMakeVisible (differenceModeButton);

    differenceModeAttachment = std::make_unique<ButtonAttachment> (
        audioProcessor.getParameters(), "differenceMode", differenceModeButton);

    //==============================================================================
    // Click Removal Section
    clickGroup.setText ("Click & Pop Removal");
    clickGroup.setTextLabelPosition (juce::Justification::centredLeft);
    addAndMakeVisible (clickGroup);

    clickSensitivitySlider.setSliderStyle (juce::Slider::RotaryHorizontalVerticalDrag);
    clickSensitivitySlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, 80, 20);
    addAndMakeVisible (clickSensitivitySlider);

    clickSensitivityLabel.setText ("Sensitivity", juce::dontSendNotification);
    clickSensitivityLabel.setJustificationType (juce::Justification::centred);
    addAndMakeVisible (clickSensitivityLabel);

    clickBypassButton.setButtonText ("Bypass");
    clickBypassButton.setColour (juce::ToggleButton::textColourId, juce::Colours::lightgrey);
    addAndMakeVisible (clickBypassButton);

    clickSensitivityAttachment = std::make_unique<SliderAttachment> (
        audioProcessor.getParameters(), "clickSensitivity", clickSensitivitySlider);
    clickBypassAttachment = std::make_unique<ButtonAttachment> (
        audioProcessor.getParameters(), "clickBypass", clickBypassButton);

    //==============================================================================
    // Noise Reduction Section
    noiseGroup.setText ("Noise Reduction");
    noiseGroup.setTextLabelPosition (juce::Justification::centredLeft);
    addAndMakeVisible (noiseGroup);

    noiseReductionSlider.setSliderStyle (juce::Slider::RotaryHorizontalVerticalDrag);
    noiseReductionSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, 80, 20);
    addAndMakeVisible (noiseReductionSlider);

    noiseReductionLabel.setText ("Reduction (dB)", juce::dontSendNotification);
    noiseReductionLabel.setJustificationType (juce::Justification::centred);
    addAndMakeVisible (noiseReductionLabel);

    noiseBypassButton.setButtonText ("Bypass");
    noiseBypassButton.setColour (juce::ToggleButton::textColourId, juce::Colours::lightgrey);
    addAndMakeVisible (noiseBypassButton);

    captureProfileButton.setButtonText ("Capture Noise Profile");
    addAndMakeVisible (captureProfileButton);
    captureProfileButton.onClick = [this]
    {
        // Capture noise profile from current audio
        audioProcessor.getNoiseReduction().captureProfile();
    };

    noiseReductionAttachment = std::make_unique<SliderAttachment> (
        audioProcessor.getParameters(), "noiseReduction", noiseReductionSlider);
    noiseBypassAttachment = std::make_unique<ButtonAttachment> (
        audioProcessor.getParameters(), "noiseBypass", noiseBypassButton);

    //==============================================================================
    // Filter Section
    filterGroup.setText ("Filters");
    filterGroup.setTextLabelPosition (juce::Justification::centredLeft);
    addAndMakeVisible (filterGroup);

    rumbleSlider.setSliderStyle (juce::Slider::RotaryHorizontalVerticalDrag);
    rumbleSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, 80, 20);
    addAndMakeVisible (rumbleSlider);

    rumbleLabel.setText ("Rumble (Hz)", juce::dontSendNotification);
    rumbleLabel.setJustificationType (juce::Justification::centred);
    addAndMakeVisible (rumbleLabel);

    rumbleBypassButton.setButtonText ("Bypass");
    rumbleBypassButton.setColour (juce::ToggleButton::textColourId, juce::Colours::lightgrey);
    addAndMakeVisible (rumbleBypassButton);

    humSlider.setSliderStyle (juce::Slider::RotaryHorizontalVerticalDrag);
    humSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, 80, 20);
    addAndMakeVisible (humSlider);

    humLabel.setText ("Hum (Hz)", juce::dontSendNotification);
    humLabel.setJustificationType (juce::Justification::centred);
    addAndMakeVisible (humLabel);

    humBypassButton.setButtonText ("Bypass");
    humBypassButton.setColour (juce::ToggleButton::textColourId, juce::Colours::lightgrey);
    addAndMakeVisible (humBypassButton);

    rumbleAttachment = std::make_unique<SliderAttachment> (
        audioProcessor.getParameters(), "rumbleFilter", rumbleSlider);
    rumbleBypassAttachment = std::make_unique<ButtonAttachment> (
        audioProcessor.getParameters(), "rumbleBypass", rumbleBypassButton);
    humAttachment = std::make_unique<SliderAttachment> (
        audioProcessor.getParameters(), "humFilter", humSlider);
    humBypassAttachment = std::make_unique<ButtonAttachment> (
        audioProcessor.getParameters(), "humBypass", humBypassButton);

    //==============================================================================
    // Graphic EQ Section
    eqGroup.setText ("Graphic EQ");
    eqGroup.setTextLabelPosition (juce::Justification::centredLeft);
    addAndMakeVisible (eqGroup);

    eqBypassButton.setButtonText ("Bypass");
    eqBypassButton.setColour (juce::ToggleButton::textColourId, juce::Colours::lightgrey);
    addAndMakeVisible (eqBypassButton);

    eqBypassAttachment = std::make_unique<ButtonAttachment> (
        audioProcessor.getParameters(), "eqBypass", eqBypassButton);

    const std::vector<juce::String> eqFreqLabels = {
        "31", "62", "125", "250", "500", "1k", "2k", "4k", "8k", "16k"
    };

    for (size_t i = 0; i < eqFreqLabels.size(); ++i)
    {
        auto slider = std::make_unique<juce::Slider>();
        slider->setSliderStyle (juce::Slider::LinearVertical);
        slider->setTextBoxStyle (juce::Slider::TextBoxBelow, false, 60, 20);
        addAndMakeVisible (*slider);

        auto label = std::make_unique<juce::Label>();
        label->setText (eqFreqLabels[i], juce::dontSendNotification);
        label->setJustificationType (juce::Justification::centred);
        addAndMakeVisible (*label);

        auto paramID = "eqBand" + juce::String (i);
        auto attachment = std::make_unique<SliderAttachment> (
            audioProcessor.getParameters(), paramID, *slider);

        eqSliders.push_back (std::move (slider));
        eqLabels.push_back (std::move (label));
        eqAttachments.push_back (std::move (attachment));
    }
}

AudioRestorationEditor::~AudioRestorationEditor()
{
}

//==============================================================================
void AudioRestorationEditor::paint (juce::Graphics& g)
{
    g.fillAll (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId));

    g.setColour (juce::Colours::white);
    g.setFont (24.0f);
    g.drawFittedText ("Audio Restoration Suite", getLocalBounds().removeFromTop (40),
                      juce::Justification::centred, 1);
}

void AudioRestorationEditor::setScaleFactor (float newScale)
{
    if (newScale == scaleFactor)
        return;

    scaleFactor = juce::jlimit (0.25f, 4.0f, newScale);

    // Apply scale transform to the entire editor
    setTransform (juce::AffineTransform::scale (scaleFactor));

    // Update the actual window size based on the scaled content
    int scaledWidth = juce::roundToInt (baseWidth * scaleFactor);
    int scaledHeight = juce::roundToInt (baseHeight * scaleFactor);

    // Update size limits based on scale
    setResizeLimits (
        juce::roundToInt (500 * scaleFactor),
        juce::roundToInt (400 * scaleFactor),
        juce::roundToInt (2560 * scaleFactor),
        juce::roundToInt (1440 * scaleFactor));

    // Resize to maintain proportions
    setSize (scaledWidth, scaledHeight);

    // Notify parent window of size change
    if (auto* peer = getPeer())
        peer->handleMovedOrResized();
}

void AudioRestorationEditor::resized()
{
    auto area = getLocalBounds().reduced (10);

    // Title area with scale selector on the right
    auto titleArea = area.removeFromTop (40);
    auto scaleArea = titleArea.removeFromRight (180);
    scaleLabel.setBounds (scaleArea.removeFromLeft (70));
    scaleSelector.setBounds (scaleArea.removeFromLeft (100).reduced (0, 5));

    // Difference mode toggle (global control)
    auto diffModeArea = area.removeFromTop (35);
    differenceModeButton.setBounds (diffModeArea.withSizeKeepingCentre (450, 30));

    area.removeFromTop (5); // Small gap

    // Top row: Click removal, Noise reduction, Filters
    // All sections now scale proportionally with window width
    auto topRow = area.removeFromTop (200);
    int totalWidth = topRow.getWidth();

    // Calculate proportional widths: Click (27%), Noise (29%), Filters (44%)
    int clickWidth = totalWidth * 27 / 100;
    int noiseWidth = totalWidth * 29 / 100;
    // Filter gets the remainder

    auto clickArea = topRow.removeFromLeft (clickWidth).reduced (5);
    clickGroup.setBounds (clickArea);

    // Place bypass button in top-right corner
    auto clickBypassArea = clickArea.removeFromTop (25).removeFromRight (90).reduced (3, 3);
    clickBypassButton.setBounds (clickBypassArea);

    auto clickContent = clickArea.reduced (10).withTrimmedTop (5);
    clickSensitivitySlider.setBounds (clickContent.removeFromTop (100).withSizeKeepingCentre (100, 100));
    clickSensitivityLabel.setBounds (clickContent.removeFromTop (20));

    auto noiseArea = topRow.removeFromLeft (noiseWidth).reduced (5);
    noiseGroup.setBounds (noiseArea);

    // Place bypass button in top-right corner
    auto noiseBypassArea = noiseArea.removeFromTop (25).removeFromRight (90).reduced (3, 3);
    noiseBypassButton.setBounds (noiseBypassArea);

    auto noiseContent = noiseArea.reduced (10).withTrimmedTop (5);
    noiseReductionSlider.setBounds (noiseContent.removeFromTop (100).withSizeKeepingCentre (100, 100));
    noiseReductionLabel.setBounds (noiseContent.removeFromTop (20));
    captureProfileButton.setBounds (noiseContent.removeFromTop (30).withSizeKeepingCentre (180, 30));

    auto filterArea = topRow.reduced (5);
    filterGroup.setBounds (filterArea);
    auto filterContent = filterArea.reduced (10).withTrimmedTop (20);

    // Safety check for width
    int halfWidth = filterContent.getWidth() > 0 ? filterContent.getWidth() / 2 : 0;
    auto rumbleArea = filterContent.removeFromLeft (halfWidth).reduced (5);

    // Place rumble bypass in top-right of its area
    auto rumbleBypassArea = rumbleArea.removeFromTop (25).removeFromRight (80).reduced (2, 2);
    rumbleBypassButton.setBounds (rumbleBypassArea);

    rumbleSlider.setBounds (rumbleArea.removeFromTop (100).withSizeKeepingCentre (100, 100));
    rumbleLabel.setBounds (rumbleArea.removeFromTop (20));

    auto humArea = filterContent.reduced (5);

    // Place hum bypass in top-right of its area
    auto humBypassArea = humArea.removeFromTop (25).removeFromRight (80).reduced (2, 2);
    humBypassButton.setBounds (humBypassArea);

    humSlider.setBounds (humArea.removeFromTop (100).withSizeKeepingCentre (100, 100));
    humLabel.setBounds (humArea.removeFromTop (20));

    // Bottom row: Graphic EQ - ensure it gets all remaining space
    area.removeFromTop (10);
    auto eqArea = area; // Use all remaining area for EQ
    eqGroup.setBounds (eqArea);

    // Place EQ bypass button in top-right corner
    auto eqBypassArea = eqArea.removeFromTop (25).removeFromRight (90).reduced (3, 3);
    eqBypassButton.setBounds (eqBypassArea);

    auto eqContent = eqArea.reduced (10).withTrimmedTop (5);

    // Safety check to prevent division by zero
    if (!eqSliders.empty() && eqContent.getWidth() > 0 && eqContent.getHeight() > 0)
    {
        int sliderWidth = eqContent.getWidth() / static_cast<int> (eqSliders.size());
        if (sliderWidth > 0)
        {
            for (size_t i = 0; i < eqSliders.size(); ++i)
            {
                auto sliderArea = eqContent.removeFromLeft (sliderWidth).reduced (3);
                eqLabels[i]->setBounds (sliderArea.removeFromBottom (25));
                eqSliders[i]->setBounds (sliderArea);
            }
        }
    }
}
