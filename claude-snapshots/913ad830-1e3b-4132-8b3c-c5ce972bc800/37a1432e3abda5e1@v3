#include "WaveformDisplay.h"

WaveformDisplay::WaveformDisplay()
    : thumbnail (128, formatManager, thumbnailCache)
{
    formatManager.registerBasicFormats();
    thumbnail.addChangeListener (this);
    startTimer (40); // 25 fps for smooth cursor updates
}

WaveformDisplay::~WaveformDisplay()
{
    thumbnail.removeChangeListener (this);
}

void WaveformDisplay::loadFile (const juce::File& file)
{
    auto* reader = formatManager.createReaderFor (file);

    if (reader != nullptr)
    {
        sampleRate = reader->sampleRate;
        delete reader;
    }

    thumbnail.setSource (new juce::FileInputSource (file));
    DBG ("Loaded waveform: " + file.getFullPathName());
    repaint();
}

void WaveformDisplay::clear()
{
    thumbnail.clear();
    clickMarkers.clear();
    selectionStart = -1;
    selectionEnd = -1;
    playbackPosition = 0.0;
    repaint();
}

void WaveformDisplay::setPlaybackPosition (double position)
{
    playbackPosition = juce::jlimit (0.0, 1.0, position);
}

void WaveformDisplay::addClickMarker (int64_t samplePosition)
{
    clickMarkers.push_back (samplePosition);
    std::sort (clickMarkers.begin(), clickMarkers.end());
    repaint();
}

void WaveformDisplay::clearClickMarkers()
{
    clickMarkers.clear();
    repaint();
}

void WaveformDisplay::setHorizontalZoom (double samplesPerPixel)
{
    horizontalZoom = juce::jmax (1.0, samplesPerPixel);
    repaint();
}

void WaveformDisplay::setVerticalZoom (double amplitudeMultiplier)
{
    verticalZoom = juce::jlimit (0.1, 10.0, amplitudeMultiplier);
    repaint();
}

void WaveformDisplay::paint (juce::Graphics& g)
{
    auto bounds = getLocalBounds();

    // Background
    g.fillAll (juce::Colour (0xff1e1e1e));

    if (thumbnail.getTotalLength() > 0.0)
    {
        drawWaveform (g, bounds);
        drawClickMarkers (g, bounds);
        drawSelection (g, bounds);
        drawPlaybackCursor (g, bounds);
    }
    else
    {
        // No audio loaded
        g.setColour (juce::Colours::grey);
        g.setFont (16.0f);
        g.drawText ("No audio file loaded", bounds, juce::Justification::centred);
    }

    // Border
    g.setColour (juce::Colours::darkgrey);
    g.drawRect (bounds, 1);
}

void WaveformDisplay::resized()
{
    // Update zoom to fit if needed
}

void WaveformDisplay::mouseDown (const juce::MouseEvent& event)
{
    if (thumbnail.getTotalLength() <= 0.0)
        return;

    double totalLength = thumbnail.getTotalLength();
    double clickTime = (event.position.x / (double) getWidth()) * totalLength;

    selectionStart = (int64_t) (clickTime * sampleRate);
    selectionEnd = selectionStart;
    isDragging = true;
    repaint();
}

void WaveformDisplay::mouseDrag (const juce::MouseEvent& event)
{
    if (!isDragging || thumbnail.getTotalLength() <= 0.0)
        return;

    double totalLength = thumbnail.getTotalLength();
    double dragTime = juce::jlimit (0.0, totalLength,
                                     (event.position.x / (double) getWidth()) * totalLength);

    selectionEnd = (int64_t) (dragTime * sampleRate);
    repaint();
}

void WaveformDisplay::mouseUp (const juce::MouseEvent&)
{
    isDragging = false;

    // Ensure selectionStart < selectionEnd
    if (selectionStart > selectionEnd)
        std::swap (selectionStart, selectionEnd);
}

void WaveformDisplay::mouseWheelMove (const juce::MouseEvent& event, const juce::MouseWheelDetails& wheel)
{
    // Horizontal zoom with mouse wheel
    if (event.mods.isShiftDown())
    {
        double zoomFactor = wheel.deltaY > 0 ? 0.9 : 1.1;
        setHorizontalZoom (horizontalZoom * zoomFactor);
    }
    // Vertical zoom with Ctrl+wheel
    else if (event.mods.isCtrlDown() || event.mods.isCommandDown())
    {
        double zoomFactor = wheel.deltaY > 0 ? 1.1 : 0.9;
        setVerticalZoom (verticalZoom * zoomFactor);
    }
}

void WaveformDisplay::changeListenerCallback (juce::ChangeBroadcaster* source)
{
    if (source == &thumbnail)
        repaint();
}

void WaveformDisplay::timerCallback()
{
    // Smooth cursor updates
    repaint();
}

void WaveformDisplay::drawWaveform (juce::Graphics& g, const juce::Rectangle<int>& bounds)
{
    // Draw waveform
    g.setColour (juce::Colour (0xff4a90e2)); // Blue waveform
    thumbnail.drawChannels (g, bounds, 0.0, thumbnail.getTotalLength(), verticalZoom);
}

void WaveformDisplay::drawClickMarkers (juce::Graphics& g, const juce::Rectangle<int>& bounds)
{
    if (thumbnail.getTotalLength() <= 0.0 || clickMarkers.empty())
        return;

    double totalLength = thumbnail.getTotalLength();

    g.setColour (juce::Colours::red.withAlpha (0.7f));

    for (auto markerSample : clickMarkers)
    {
        double markerTime = markerSample / sampleRate;
        if (markerTime < 0.0 || markerTime > totalLength)
            continue;

        float x = (float) ((markerTime / totalLength) * bounds.getWidth());
        g.drawVerticalLine ((int) x, (float) bounds.getY(), (float) bounds.getBottom());

        // Draw small circle at marker
        g.fillEllipse (x - 3.0f, bounds.getCentreY() - 3.0f, 6.0f, 6.0f);
    }
}

void WaveformDisplay::drawPlaybackCursor (juce::Graphics& g, const juce::Rectangle<int>& bounds)
{
    if (playbackPosition <= 0.0)
        return;

    g.setColour (juce::Colours::yellow.withAlpha (0.8f));
    float x = (float) (playbackPosition * bounds.getWidth());
    g.drawVerticalLine ((int) x, (float) bounds.getY(), (float) bounds.getBottom());
}

void WaveformDisplay::drawSelection (juce::Graphics& g, const juce::Rectangle<int>& bounds)
{
    if (selectionStart < 0 || selectionEnd < 0 || thumbnail.getTotalLength() <= 0.0)
        return;

    double totalSamples = thumbnail.getTotalLength() * sampleRate;

    double startPos = selectionStart / totalSamples;
    double endPos = selectionEnd / totalSamples;

    float x1 = (float) (startPos * bounds.getWidth());
    float x2 = (float) (endPos * bounds.getWidth());

    g.setColour (juce::Colours::white.withAlpha (0.2f));
    g.fillRect (x1, (float) bounds.getY(), x2 - x1, (float) bounds.getHeight());

    g.setColour (juce::Colours::white.withAlpha (0.5f));
    g.drawRect (x1, (float) bounds.getY(), x2 - x1, (float) bounds.getHeight(), 1.0f);
}
