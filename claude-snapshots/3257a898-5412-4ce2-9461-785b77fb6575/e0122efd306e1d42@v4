#include "StandaloneWindow.h"

//==============================================================================
// StandaloneWindow Implementation
//==============================================================================

StandaloneWindow::StandaloneWindow()
    : DocumentWindow ("Vinyl Restoration Suite",
                      juce::Colour (0xff2e2e2e),
                      DocumentWindow::allButtons),
      menuBar (this)
{
    setUsingNativeTitleBar (true);
    setResizable (true, true);

    // Initialize audio device
    juce::String audioError = audioDeviceManager.initialise (
        0,     // number of input channels
        2,     // number of output channels
        nullptr,  // saved state
        true   // select default device on failure
    );

    if (audioError.isNotEmpty())
    {
        DBG ("Audio device error: " + audioError);
    }

    // Setup audio transport
    transportSource.addChangeListener (this);
    audioSourcePlayer.setSource (&transportSource);
    audioDeviceManager.addAudioCallback (&audioSourcePlayer);

    // Create main component
    mainComponent = std::make_unique<MainComponent>();
    mainComponent->setParentWindow (this);

    // Wire up waveform double-click to seek playback
    mainComponent->getWaveformDisplay().onSeekPosition = [this](double position)
    {
        if (transportSource.getTotalLength() > 0.0)
        {
            double timeInSeconds = position * transportSource.getLengthInSeconds();
            transportSource.setPosition (timeInSeconds);
            DBG ("Seek to: " + juce::String (timeInSeconds) + " seconds");
        }
    };

    // Add menu bar to main component using base class method
    mainComponent->Component::addAndMakeVisible (menuBar);

    setContentOwned (mainComponent.get(), true);

    // Set initial size
    centreWithSize (1200, 800);

    // Load recent files
    recentFiles.setMaxNumberOfItems (10);

    // Start timer for playback position updates
    startTimer (40); // 25 fps

    setVisible (true);
}

StandaloneWindow::~StandaloneWindow()
{
    // Stop audio playback
    transportSource.setSource (nullptr);
    audioSourcePlayer.setSource (nullptr);
    audioDeviceManager.removeAudioCallback (&audioSourcePlayer);
    transportSource.removeChangeListener (this);

    setMenuBar (nullptr);
}

void StandaloneWindow::closeButtonPressed()
{
    if (hasUnsavedChanges)
    {
        int result = juce::AlertWindow::showYesNoCancelBox (
            juce::AlertWindow::QuestionIcon,
            "Unsaved Changes",
            "Do you want to save your changes before closing?",
            "Save", "Don't Save", "Cancel",
            nullptr, nullptr
        );

        if (result == 0) // Cancel
            return;
        else if (result == 1) // Save
        {
            if (currentFile.exists())
            {
                saveFile (currentFile);
            }
            else
            {
                // No file exists, show save dialog
                exportFile();
                return; // exportFile is async, will handle quit after save
            }
        }
        // result == 2 means "Don't Save" - fall through to quit
    }

    juce::JUCEApplication::getInstance()->systemRequestedQuit();
}

//==============================================================================
// Drag and Drop
//==============================================================================

bool StandaloneWindow::isInterestedInFileDrag (const juce::StringArray& files)
{
    for (const auto& file : files)
    {
        juce::File f (file);
        if (f.hasFileExtension ("wav;flac;aiff;mp3;ogg"))
            return true;
    }
    return false;
}

void StandaloneWindow::filesDropped (const juce::StringArray& files, int, int)
{
    if (files.size() > 0)
    {
        juce::File file (files[0]);
        openFile (file);
    }
}

//==============================================================================
// Menu Bar
//==============================================================================

juce::StringArray StandaloneWindow::getMenuBarNames()
{
    return {"File", "Edit", "Process", "View", "Options", "Help"};
}

juce::PopupMenu StandaloneWindow::getMenuForIndex (int topLevelMenuIndex, const juce::String&)
{
    juce::PopupMenu menu;

    if (topLevelMenuIndex == 0) // File
    {
        menu.addItem (fileOpen, "Open...                   Ctrl+O");
        menu.addItem (fileClose, "Close File                Ctrl+W", currentFile.exists());
        menu.addSeparator();
        menu.addItem (fileSave, "Save                      Ctrl+S", currentFile.exists());
        menu.addItem (fileSaveAs, "Save As...             Ctrl+Shift+S");
        menu.addSeparator();
        menu.addItem (fileExport, "Export Audio...           Ctrl+E", audioBuffer.getNumSamples() > 0);
        menu.addSeparator();

        // Recent files submenu
        juce::PopupMenu recentMenu;
        recentFiles.createPopupMenuItems (recentMenu, 100, true, true);
        menu.addSubMenu ("Recent Files", recentMenu);
        menu.addItem (fileRecentClear, "Clear Recent Files");

        menu.addSeparator();
        menu.addItem (fileExit, "Exit                      Ctrl+Q");
    }
    else if (topLevelMenuIndex == 1) // Edit
    {
        menu.addItem (editUndo, "Undo                      Ctrl+Z", false);
        menu.addItem (editRedo, "Redo                      Ctrl+Y", false);
        menu.addSeparator();
        menu.addItem (editSelectAll, "Select All                Ctrl+A", false);
        menu.addItem (editDeselect, "Deselect                  Ctrl+D", false);
    }
    else if (topLevelMenuIndex == 2) // Process
    {
        bool hasAudio = audioBuffer.getNumSamples() > 0;
        menu.addItem (processDetectClicks, "Detect Clicks", hasAudio);
        menu.addItem (processRemoveClicks, "Remove Clicks", hasAudio);
        menu.addSeparator();
        menu.addItem (processNoiseReduction, "Noise Reduction...", hasAudio);
        menu.addSeparator();
        menu.addItem (processCutAndSplice, "Cut and Splice...", hasAudio);
        menu.addSeparator();
        menu.addItem (processGraphicEQ, "Graphic Equaliser...", hasAudio);
        menu.addSeparator();
        menu.addItem (processNormalise, "Normalise...", hasAudio);
        menu.addItem (processChannelBalance, "Channel Balance...", hasAudio);
        menu.addSeparator();
        menu.addItem (processWowFlutterRemoval, "Wow & Flutter Removal...", hasAudio);
        menu.addItem (processDropoutRestoration, "Dropout Restoration...", hasAudio);
        menu.addItem (processSpeedCorrection, "Speed Correction...", hasAudio);
        menu.addSeparator();
        menu.addItem (processDetectTracks, "Detect Tracks", hasAudio);
        menu.addItem (processSplitTracks, "Split Tracks...", hasAudio);
        menu.addSeparator();
        menu.addItem (processBatchProcess, "Batch Process...");
    }
    else if (topLevelMenuIndex == 3) // View
    {
        menu.addItem (viewZoomIn, "Zoom In                   Ctrl++");
        menu.addItem (viewZoomOut, "Zoom Out                  Ctrl+-");
        menu.addItem (viewZoomFit, "Zoom to Fit               Ctrl+0");
        menu.addSeparator();
        menu.addItem (viewShowCorrectionList, "Show Correction List", true, true);
    }
    else if (topLevelMenuIndex == 4) // Options
    {
        menu.addItem (optionsAudioSettings, "Audio Settings...");
    }
    else if (topLevelMenuIndex == 5) // Help
    {
        menu.addItem (helpAbout, "About");
        menu.addItem (helpDocumentation, "Documentation", false);
    }

    return menu;
}

void StandaloneWindow::menuItemSelected (int menuItemID, int)
{
    // Handle recent files
    if (menuItemID >= 100 && menuItemID < 200)
    {
        juce::File file = recentFiles.getFile (menuItemID - 100);
        if (file.exists())
            openFile (file);
        return;
    }

    // Handle menu commands
    switch (menuItemID)
    {
        case fileOpen:
        {
            auto chooser = std::make_shared<juce::FileChooser> ("Open Audio File",
                                       juce::File::getSpecialLocation (juce::File::userHomeDirectory),
                                       "*.wav;*.flac;*.aiff;*.ogg;*.mp3");

            chooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
                [this, chooser] (const juce::FileChooser&)
                {
                    auto file = chooser->getResult();
                    if (file.existsAsFile())
                        openFile (file);
                });
            break;
        }

        case fileClose:
            closeFile();
            break;

        case fileSave:
            if (currentFile.exists())
                saveFile (currentFile);
            break;

        case fileSaveAs:
        {
            auto chooser = std::make_shared<juce::FileChooser> ("Save Session",
                                       juce::File::getSpecialLocation (juce::File::userHomeDirectory),
                                       "*.vrs");

            chooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
                [this, chooser] (const juce::FileChooser&)
                {
                    auto file = chooser->getResult();
                    if (file != juce::File())
                        saveFile (file);
                });
            break;
        }

        case fileExport:
            exportFile();
            break;

        case fileRecentClear:
            recentFiles.clear();
            menuItemsChanged();
            break;

        case fileExit:
            juce::JUCEApplication::getInstance()->systemRequestedQuit();
            break;

        case processDetectClicks:
            detectClicks();
            break;

        case processRemoveClicks:
            removeClicks();
            break;

        case processNoiseReduction:
            applyNoiseReduction();
            break;

        case processDetectTracks:
            detectTracks();
            break;

        case processSplitTracks:
            splitTracks();
            break;

        case processBatchProcess:
            showBatchProcessor();
            break;

        case optionsAudioSettings:
            showAudioSettings();
            break;

        case helpAbout:
            showAboutDialog();
            break;

        default:
            break;
    }
}

//==============================================================================
// Timer callback
//==============================================================================

void StandaloneWindow::timerCallback()
{
    // Update playback position if playing
    if (transportSource.isPlaying())
    {
        double position = transportSource.getCurrentPosition() / transportSource.getLengthInSeconds();
        mainComponent->updatePlaybackPosition (position);
    }
}

void StandaloneWindow::changeListenerCallback (juce::ChangeBroadcaster*)
{
    // Transport state changed (started/stopped)
    if (transportSource.hasStreamFinished())
    {
        transportSource.setPosition (0.0);
        isPlaying = false;
    }
}

//==============================================================================
// Helper Methods
//==============================================================================

void StandaloneWindow::openFile (const juce::File& file)
{
    if (!file.exists())
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "File Not Found",
                                                "The selected file does not exist.");
        return;
    }

    auto fileSizeMB = file.getSize() / (1024.0 * 1024.0);

    // For large files (>50MB), use progress dialog
    if (fileSizeMB > 50.0)
    {
        openFileWithProgress (file);
        return;
    }

    // For smaller files, load directly with status update
    mainComponent->getCorrectionListView().setStatusText (
        "Loading " + file.getFileName() + " (" +
        juce::String (fileSizeMB, 1) + " MB)..."
    );

    // Load audio file
    if (fileManager.loadAudioFile (file, audioBuffer, sampleRate))
    {
        finishFileLoad (file);
    }
    else
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Error",
                                                "Failed to load audio file.");
        mainComponent->getCorrectionListView().setStatusText ("Ready");
    }
}

void StandaloneWindow::openFileWithProgress (const juce::File& file)
{
    // Show loading status with file info
    auto fileSizeMB = file.getSize() / (1024.0 * 1024.0);
    mainComponent->getCorrectionListView().setStatusText (
        "Loading " + file.getFileName() + " (" +
        juce::String (fileSizeMB, 1) + " MB)..."
    );

    // Force repaint to show status
    mainComponent->getCorrectionListView().repaint();

    loadingProgress = 0.0;
    loadingFile = file;

    // Track last update time for throttling
    auto lastUpdateTime = juce::Time::getMillisecondCounter();

    // Load with progress updates to status bar
    bool success = fileManager.loadAudioFileWithProgress (
        file, audioBuffer, sampleRate,
        [this, &lastUpdateTime] (double prog, const juce::String&) -> bool
        {
            loadingProgress = prog;

            // Throttle UI updates to every 100ms
            auto now = juce::Time::getMillisecondCounter();
            if (now - lastUpdateTime > 100)
            {
                lastUpdateTime = now;
                int percent = static_cast<int> (prog * 100.0);
                mainComponent->getCorrectionListView().setStatusText (
                    "Loading... " + juce::String (percent) + "%"
                );
                mainComponent->getCorrectionListView().repaint();
            }

            return true;  // Continue loading
        }
    );

    if (success)
    {
        finishFileLoad (file);
    }
    else
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Error",
                                                "Failed to load audio file.");
        mainComponent->getCorrectionListView().setStatusText ("Ready");
    }
}

void StandaloneWindow::finishFileLoad (const juce::File& file)
{
    currentFile = file;
    recentFiles.addFile (file);

    // Update waveform display
    mainComponent->getWaveformDisplay().loadFile (file);
    mainComponent->setAudioBuffer (&audioBuffer, sampleRate);

    // Load into transport source for playback
    juce::AudioFormatManager formatManager;
    formatManager.registerBasicFormats();
    formatManager.registerFormat (new juce::FlacAudioFormat(), true);
    formatManager.registerFormat (new juce::OggVorbisAudioFormat(), true);

    #if JUCE_USE_MP3AUDIOFORMAT
    formatManager.registerFormat (new juce::MP3AudioFormat(), true);
    #endif

    auto* reader = formatManager.createReaderFor (file);

    if (reader != nullptr)
    {
        readerSource.reset (new juce::AudioFormatReaderSource (reader, true));
        transportSource.setSource (readerSource.get(), 0, nullptr, reader->sampleRate);
    }

    // Clear corrections
    mainComponent->getCorrectionListView().clearCorrections();

    hasUnsavedChanges = false;
    updateTitle();

    DBG ("Opened file: " + file.getFullPathName());

    auto durationSec = audioBuffer.getNumSamples() / sampleRate;
    juce::String status = "Loaded: " + juce::String (durationSec / 60.0, 1) + " min, " +
                          juce::String (sampleRate / 1000.0, 1) + " kHz";
    mainComponent->getCorrectionListView().setStatusText (status);
}


void StandaloneWindow::closeFile()
{
    // Stop playback
    transportSource.stop();
    transportSource.setSource (nullptr);
    readerSource.reset();
    isPlaying = false;

    // Clear audio buffer
    audioBuffer.setSize (0, 0);
    currentFile = juce::File();

    // Clear displays
    mainComponent->getWaveformDisplay().clear();
    mainComponent->getCorrectionListView().clearCorrections();
    mainComponent->setAudioBuffer (nullptr, sampleRate);

    // Reset state
    hasUnsavedChanges = false;
    updateTitle();

    mainComponent->getCorrectionListView().setStatusText ("No file loaded");
    DBG ("Closed file");
}

void StandaloneWindow::saveFile (const juce::File& file)
{
    // Save session (corrections, settings, etc.)
    juce::var sessionData;
    // TODO: Build session data from current state

    if (fileManager.saveSession (file, currentFile, sessionData))
    {
        hasUnsavedChanges = false;
        updateTitle();
        DBG ("Saved session: " + file.getFullPathName());
    }
    else
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Save Failed",
                                                "Failed to save session file.");
    }
}

void StandaloneWindow::exportFile()
{
    auto chooser = std::make_shared<juce::FileChooser> ("Export Audio",
                               currentFile.getParentDirectory(),
                               "*.wav;*.flac;*.ogg");

    chooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this, chooser] (const juce::FileChooser&)
        {
            juce::File outputFile = chooser->getResult();

            if (outputFile != juce::File())
            {
                if (fileManager.saveAudioFile (outputFile, audioBuffer, sampleRate, 24))
                {
                    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                                            "Export Complete",
                                                            "Audio exported successfully.");
                }
                else
                {
                    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                            "Export Failed",
                                                            "Failed to export audio file.");
                }
            }
        });
}

void StandaloneWindow::detectClicks()
{
    if (audioBuffer.getNumSamples() == 0)
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "No Audio",
                                                "Please load an audio file first.");
        return;
    }

    mainComponent->getCorrectionListView().setStatusText ("Detecting clicks...");
    DBG ("Starting click detection on " + juce::String (audioBuffer.getNumSamples()) + " samples");

    // Configure click detection
    juce::dsp::ProcessSpec spec;
    spec.sampleRate = sampleRate;
    spec.numChannels = static_cast<juce::uint32> (audioBuffer.getNumChannels());
    spec.maximumBlockSize = 2048;

    clickRemovalProcessor.prepare (spec);
    clickRemovalProcessor.reset();  // Clear previous detections
    clickRemovalProcessor.setSensitivity (60.0f);  // Slightly higher sensitivity for better detection
    clickRemovalProcessor.setStoreDetectedClicks (true);  // IMPORTANT: Store clicks for GUI display
    clickRemovalProcessor.setApplyRemoval (false);  // Detection only - don't modify audio
    clickRemovalProcessor.resetSamplePosition();   // Reset position counter

    // Create a copy of the buffer for detection (non-destructive scan)
    juce::AudioBuffer<float> scanBuffer;
    scanBuffer.makeCopyOf (audioBuffer);

    // Process in blocks to detect clicks
    const int blockSize = 2048;
    int totalClicks = 0;

    for (int startSample = 0; startSample < scanBuffer.getNumSamples(); startSample += blockSize)
    {
        int samplesThisBlock = juce::jmin (blockSize, scanBuffer.getNumSamples() - startSample);

        juce::dsp::AudioBlock<float> block (scanBuffer.getArrayOfWritePointers(),
                                            static_cast<size_t> (scanBuffer.getNumChannels()),
                                            static_cast<size_t> (startSample),
                                            static_cast<size_t> (samplesThisBlock));

        juce::dsp::ProcessContextReplacing<float> context (block);
        clickRemovalProcessor.process (context);

        totalClicks += clickRemovalProcessor.getClicksDetectedLastBlock();
    }

    DBG ("Total clicks detected during scan: " + juce::String (totalClicks));

    // Get detected clicks and add to correction list
    const auto& detectedClicks = clickRemovalProcessor.getDetectedClicks();

    DBG ("Clicks stored in vector: " + juce::String (detectedClicks.size()));

    mainComponent->getCorrectionListView().clearCorrections();
    mainComponent->getWaveformDisplay().clearClickMarkers();

    for (const auto& click : detectedClicks)
    {
        mainComponent->getCorrectionListView().addCorrection (
            click.position,
            click.magnitude,
            click.width,
            click.isManual ? "Manual" : "Auto",
            false
        );

        // Add marker to waveform display
        mainComponent->getWaveformDisplay().addClickMarker (click.position);
    }

    if (!detectedClicks.empty())
        hasUnsavedChanges = true;

    updateTitle();

    juce::String message = "Detected " + juce::String (detectedClicks.size()) + " clicks/pops.";
    mainComponent->getCorrectionListView().setStatusText (message);

    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Click Detection Complete",
                                            message + "\n\nUse 'Remove Clicks' to apply corrections.");
}

void StandaloneWindow::removeClicks()
{
    if (audioBuffer.getNumSamples() == 0)
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "No Audio",
                                                "Please load an audio file first.");
        return;
    }

    mainComponent->getCorrectionListView().setStatusText ("Removing clicks...");
    DBG ("Starting click removal on " + juce::String (audioBuffer.getNumSamples()) + " samples");

    // Configure click removal processor
    juce::dsp::ProcessSpec spec;
    spec.sampleRate = sampleRate;
    spec.numChannels = static_cast<juce::uint32> (audioBuffer.getNumChannels());
    spec.maximumBlockSize = 2048;

    clickRemovalProcessor.prepare (spec);
    clickRemovalProcessor.reset();
    clickRemovalProcessor.setSensitivity (60.0f);
    clickRemovalProcessor.setRemovalMethod (ClickRemoval::Automatic);
    clickRemovalProcessor.setStoreDetectedClicks (false);  // Don't need to store, just remove
    clickRemovalProcessor.setApplyRemoval (true);  // Actually remove the clicks
    clickRemovalProcessor.resetSamplePosition();

    // Process the actual audio buffer (destructive operation)
    const int blockSize = 2048;
    int totalClicksRemoved = 0;

    for (int startSample = 0; startSample < audioBuffer.getNumSamples(); startSample += blockSize)
    {
        int samplesThisBlock = juce::jmin (blockSize, audioBuffer.getNumSamples() - startSample);

        juce::dsp::AudioBlock<float> block (audioBuffer.getArrayOfWritePointers(),
                                            static_cast<size_t> (audioBuffer.getNumChannels()),
                                            static_cast<size_t> (startSample),
                                            static_cast<size_t> (samplesThisBlock));

        juce::dsp::ProcessContextReplacing<float> context (block);
        clickRemovalProcessor.process (context);

        totalClicksRemoved += clickRemovalProcessor.getClicksDetectedLastBlock();
    }

    DBG ("Total clicks removed: " + juce::String (totalClicksRemoved));

    // Mark corrections as applied in the list
    mainComponent->getCorrectionListView().markAllApplied();

    // Update waveform display to show processed audio
    mainComponent->getWaveformDisplay().updateFromBuffer (audioBuffer, sampleRate);

    hasUnsavedChanges = true;
    updateTitle();

    juce::String message = "Removed " + juce::String (totalClicksRemoved) + " clicks/pops.";
    mainComponent->getCorrectionListView().setStatusText (message);

    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Click Removal Complete",
                                            message);
}

void StandaloneWindow::applyNoiseReduction()
{
    if (audioBuffer.getNumSamples() == 0)
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "No Audio",
                                                "Please load an audio file first.");
        return;
    }

    // Create noise reduction settings dialog
    auto* dialog = new juce::AlertWindow ("Noise Reduction Settings",
                                          "Configure noise reduction parameters:",
                                          juce::AlertWindow::QuestionIcon);

    dialog->addTextEditor ("reduction", "12", "Reduction Amount (dB):");
    dialog->addTextEditor ("profileStart", "0", "Profile Start (seconds):");
    dialog->addTextEditor ("profileLength", "1", "Profile Length (seconds):");

    dialog->addButton ("Apply", 1);
    dialog->addButton ("Cancel", 0);

    dialog->enterModalState (true, juce::ModalCallbackFunction::create (
        [this, dialog] (int result)
        {
            if (result == 1)
            {
                float reductionDB = dialog->getTextEditorContents ("reduction").getFloatValue();
                float profileStart = dialog->getTextEditorContents ("profileStart").getFloatValue();
                float profileLength = dialog->getTextEditorContents ("profileLength").getFloatValue();

                reductionDB = juce::jlimit (0.0f, 24.0f, reductionDB);
                profileStart = juce::jmax (0.0f, profileStart);
                profileLength = juce::jmax (0.1f, profileLength);

                // Apply noise reduction on message thread (for GUI responsiveness)
                juce::MessageManager::callAsync ([this, reductionDB, profileStart, profileLength]()
                {
                    applyNoiseReductionWithSettings (reductionDB, profileStart, profileLength);
                });
            }
            delete dialog;
        }
    ), true);
}

void StandaloneWindow::applyNoiseReductionWithSettings (float reductionDB, float profileStartSec, float profileLengthSec)
{
    mainComponent->getCorrectionListView().setStatusText ("Applying noise reduction...");

    // Configure noise reduction processor
    juce::dsp::ProcessSpec spec;
    spec.sampleRate = sampleRate;
    spec.numChannels = static_cast<juce::uint32> (audioBuffer.getNumChannels());
    spec.maximumBlockSize = 2048;

    noiseReductionProcessor.prepare (spec);
    noiseReductionProcessor.setReduction (reductionDB);

    // Calculate profile sample range
    int profileStartSample = static_cast<int> (profileStartSec * sampleRate);
    int profileLengthSamples = static_cast<int> (profileLengthSec * sampleRate);
    profileStartSample = juce::jlimit (0, audioBuffer.getNumSamples() - 1, profileStartSample);
    profileLengthSamples = juce::jmin (profileLengthSamples, audioBuffer.getNumSamples() - profileStartSample);

    // Capture noise profile from specified section
    noiseReductionProcessor.captureProfile();

    // Feed profile section to the processor
    const int blockSize = 2048;
    for (int startSample = profileStartSample;
         startSample < profileStartSample + profileLengthSamples;
         startSample += blockSize)
    {
        int samplesThisBlock = juce::jmin (blockSize, profileStartSample + profileLengthSamples - startSample);

        juce::dsp::AudioBlock<float> block (audioBuffer.getArrayOfWritePointers(),
                                            static_cast<size_t> (audioBuffer.getNumChannels()),
                                            static_cast<size_t> (startSample),
                                            static_cast<size_t> (samplesThisBlock));

        juce::dsp::ProcessContextReplacing<float> context (block);
        noiseReductionProcessor.process (context);

        if (noiseReductionProcessor.hasProfile())
            break;  // Profile captured
    }

    if (!noiseReductionProcessor.hasProfile())
    {
        mainComponent->getCorrectionListView().setStatusText ("Failed to capture noise profile");
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Noise Reduction Failed",
                                                "Could not capture noise profile. Try a different section.");
        return;
    }

    // Now process the entire audio buffer
    mainComponent->getCorrectionListView().setStatusText ("Processing audio...");

    for (int startSample = 0; startSample < audioBuffer.getNumSamples(); startSample += blockSize)
    {
        int samplesThisBlock = juce::jmin (blockSize, audioBuffer.getNumSamples() - startSample);

        juce::dsp::AudioBlock<float> block (audioBuffer.getArrayOfWritePointers(),
                                            static_cast<size_t> (audioBuffer.getNumChannels()),
                                            static_cast<size_t> (startSample),
                                            static_cast<size_t> (samplesThisBlock));

        juce::dsp::ProcessContextReplacing<float> context (block);
        noiseReductionProcessor.process (context);
    }

    // Update waveform display
    mainComponent->getWaveformDisplay().updateFromBuffer (audioBuffer, sampleRate);

    hasUnsavedChanges = true;
    updateTitle();

    juce::String message = "Applied " + juce::String (reductionDB, 1) + " dB noise reduction.";
    mainComponent->getCorrectionListView().setStatusText (message);

    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Noise Reduction Complete",
                                            message);
}

void StandaloneWindow::detectTracks()
{
    if (audioBuffer.getNumSamples() == 0)
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "No Audio",
                                                "Please load an audio file first.");
        return;
    }

    TrackDetector detector;
    TrackDetector::DetectionSettings settings;
    settings.silenceThresholdDb = -40.0f;
    settings.minSilenceDurationSeconds = 2.0;
    settings.minTrackDurationSeconds = 10.0;

    auto boundaries = detector.detectTracks (audioBuffer, sampleRate, settings);

    juce::String message = "Detected " + juce::String (boundaries.size()) + " track boundaries.";
    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Track Detection",
                                            message);
}

void StandaloneWindow::splitTracks()
{
    // TODO: Implement track splitting with dialog
    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Split Tracks",
                                            "Track splitting will be implemented here.");
}

void StandaloneWindow::showBatchProcessor()
{
    // Create batch processor settings dialog
    auto* dialog = new juce::AlertWindow ("Batch Processor",
                                          "Configure batch processing settings:",
                                          juce::AlertWindow::QuestionIcon);

    dialog->addTextBlock ("Select files to process and configure settings:");

    // Settings
    dialog->addComboBox ("clickRemoval", {"Disabled", "Low (25)", "Medium (50)", "High (75)", "Maximum (100)"}, "Click Removal:");
    dialog->getComboBoxComponent ("clickRemoval")->setSelectedItemIndex (2); // Default: Medium

    dialog->addComboBox ("noiseReduction", {"Disabled", "6 dB", "12 dB", "18 dB", "24 dB"}, "Noise Reduction:");
    dialog->getComboBoxComponent ("noiseReduction")->setSelectedItemIndex (0); // Default: Disabled

    dialog->addComboBox ("rumbleFilter", {"Disabled", "20 Hz", "40 Hz", "60 Hz", "80 Hz"}, "Rumble Filter:");
    dialog->getComboBoxComponent ("rumbleFilter")->setSelectedItemIndex (0); // Default: Disabled

    dialog->addComboBox ("humFilter", {"Disabled", "50 Hz (EU)", "60 Hz (US)"}, "Hum Filter:");
    dialog->getComboBoxComponent ("humFilter")->setSelectedItemIndex (0); // Default: Disabled

    dialog->addComboBox ("normalize", {"Disabled", "-0.5 dB", "-1 dB", "-3 dB"}, "Normalize:");
    dialog->getComboBoxComponent ("normalize")->setSelectedItemIndex (1); // Default: -0.5 dB

    dialog->addComboBox ("bitDepth", {"16-bit", "24-bit", "32-bit float"}, "Output Bit Depth:");
    dialog->getComboBoxComponent ("bitDepth")->setSelectedItemIndex (1); // Default: 24-bit

    dialog->addButton ("Select Files...", 1);
    dialog->addButton ("Cancel", 0);

    dialog->enterModalState (true, juce::ModalCallbackFunction::create (
        [this, dialog] (int result)
        {
            if (result == 1)
            {
                // Get settings from dialog
                BatchProcessor::Settings settings;

                int clickIdx = dialog->getComboBoxComponent ("clickRemoval")->getSelectedItemIndex();
                settings.clickRemoval = clickIdx > 0;
                settings.clickSensitivity = clickIdx > 0 ? (clickIdx * 25.0f) : 0.0f;

                int noiseIdx = dialog->getComboBoxComponent ("noiseReduction")->getSelectedItemIndex();
                settings.noiseReduction = noiseIdx > 0;
                settings.noiseReductionDB = noiseIdx > 0 ? (noiseIdx * 6.0f) : 0.0f;

                int rumbleIdx = dialog->getComboBoxComponent ("rumbleFilter")->getSelectedItemIndex();
                settings.rumbleFilter = rumbleIdx > 0;
                settings.rumbleFreq = rumbleIdx > 0 ? (rumbleIdx * 20.0f) : 20.0f;

                int humIdx = dialog->getComboBoxComponent ("humFilter")->getSelectedItemIndex();
                settings.humFilter = humIdx > 0;
                settings.humFreq = humIdx == 1 ? 50.0f : 60.0f;

                int normIdx = dialog->getComboBoxComponent ("normalize")->getSelectedItemIndex();
                settings.normalize = normIdx > 0;
                float normValues[] = {0.0f, -0.5f, -1.0f, -3.0f};
                settings.normalizeDB = normValues[normIdx];

                int bitIdx = dialog->getComboBoxComponent ("bitDepth")->getSelectedItemIndex();
                int bitDepths[] = {16, 24, 32};
                settings.outputBitDepth = bitDepths[bitIdx];

                // Show file chooser
                auto chooser = std::make_shared<juce::FileChooser> ("Select Audio Files to Process",
                               juce::File::getSpecialLocation (juce::File::userHomeDirectory),
                               "*.wav;*.flac;*.aiff;*.ogg;*.mp3");

                chooser->launchAsync (juce::FileBrowserComponent::openMode |
                                     juce::FileBrowserComponent::canSelectFiles |
                                     juce::FileBrowserComponent::canSelectMultipleItems,
                    [this, settings, chooser] (const juce::FileChooser&)
                    {
                        auto results = chooser->getResults();
                        if (results.size() > 0)
                        {
                            startBatchProcessing (results, settings);
                        }
                    });
            }
            delete dialog;
        }
    ), true);
}

void StandaloneWindow::startBatchProcessing (const juce::Array<juce::File>& files, const BatchProcessor::Settings& settings)
{
    // Create batch processor
    auto batchProcessor = std::make_unique<BatchProcessor>();

    // Add files to queue
    for (const auto& file : files)
    {
        batchProcessor->addFile (file);
    }

    // Set progress callback
    batchProcessor->setProgressCallback ([this] (const BatchProcessor::ProgressInfo& info)
    {
        mainComponent->getCorrectionListView().setStatusText (
            "Batch: " + juce::String (info.currentFileIndex) + "/" +
            juce::String (info.totalFiles) + " - " + info.currentFileName);
    });

    // Set completion callback
    batchProcessor->setCompletionCallback ([this] (bool success, const juce::String& message)
    {
        mainComponent->getCorrectionListView().setStatusText ("Ready");
        juce::AlertWindow::showMessageBoxAsync (
            success ? juce::AlertWindow::InfoIcon : juce::AlertWindow::WarningIcon,
            "Batch Processing Complete",
            message);
    });

    // Start processing
    mainComponent->getCorrectionListView().setStatusText ("Starting batch processing...");
    batchProcessor->startProcessing (settings);

    // Note: batchProcessor will be destroyed here, but the thread will continue
    // This is a limitation - in production, we'd want to keep the processor alive
    // For now, we'll just start it and let it run
    batchProcessor.release();  // Release ownership to prevent deletion
}

void StandaloneWindow::showAboutDialog()
{
    // Create custom circular vinyl record dialog
    class CircularVinylDialog : public juce::Component
    {
    public:
        CircularVinylDialog()
        {
            setSize (400, 400);

            // Make window click-to-close
            setInterceptsMouseClicks (true, true);
        }

        void paint (juce::Graphics& g) override
        {
            auto bounds = getLocalBounds().toFloat();
            auto centre = bounds.getCentre();
            float radius = juce::jmin (bounds.getWidth(), bounds.getHeight()) / 2.0f;

            // Draw outer glow/shadow
            g.setColour (juce::Colours::black.withAlpha (0.3f));
            g.fillEllipse (centre.x - radius - 10, centre.y - radius - 10,
                          (radius + 10) * 2.0f, (radius + 10) * 2.0f);

            // Draw vinyl record (black disc)
            g.setColour (juce::Colour (0xff0a0a0a));
            g.fillEllipse (centre.x - radius, centre.y - radius, radius * 2.0f, radius * 2.0f);

            // Draw grooves (concentric circles)
            g.setColour (juce::Colour (0xff1a1a1a));
            for (float r = radius * 0.55f; r < radius; r += 2.5f)
            {
                g.drawEllipse (centre.x - r, centre.y - r, r * 2.0f, r * 2.0f, 0.6f);
            }

            // Draw label area (center circle) with gold gradient
            float labelRadius = radius * 0.52f;
            juce::ColourGradient gradient (juce::Colour (0xffdaa520), centre,  // Gold
                                          juce::Colour (0xffb8860b), centre.translated (labelRadius * 0.5f, labelRadius * 0.5f),
                                          true);
            g.setGradientFill (gradient);
            g.fillEllipse (centre.x - labelRadius, centre.y - labelRadius,
                          labelRadius * 2.0f, labelRadius * 2.0f);

            // Draw label border
            g.setColour (juce::Colour (0xff8b7355));
            g.drawEllipse (centre.x - labelRadius, centre.y - labelRadius,
                          labelRadius * 2.0f, labelRadius * 2.0f, 2.0f);

            // Draw spindle hole (center)
            float holeRadius = radius * 0.06f;
            g.setColour (juce::Colours::black);
            g.fillEllipse (centre.x - holeRadius, centre.y - holeRadius,
                          holeRadius * 2.0f, holeRadius * 2.0f);

            // Draw reflection/shine on vinyl
            g.setColour (juce::Colours::white.withAlpha (0.08f));
            g.fillEllipse (centre.x - radius * 0.8f, centre.y - radius * 0.9f,
                          radius * 0.7f, radius * 0.4f);

            // Draw text on label
            g.setColour (juce::Colours::black);

            // Title
            g.setFont (juce::Font (juce::FontOptions (labelRadius * 0.15f)).boldened());
            g.drawText ("Vinyl Restoration Suite",
                       centre.x - labelRadius * 0.9f, centre.y - labelRadius * 0.8f,
                       labelRadius * 1.8f, labelRadius * 0.25f,
                       juce::Justification::centred);

            // Version
            g.setFont (juce::Font (juce::FontOptions (labelRadius * 0.10f)));
            g.drawText ("Version 1.5.2",
                       centre.x - labelRadius * 0.9f, centre.y - labelRadius * 0.5f,
                       labelRadius * 1.8f, labelRadius * 0.15f,
                       juce::Justification::centred);

            // Description
            g.setFont (juce::Font (juce::FontOptions (labelRadius * 0.08f)));
            juce::String description = "Professional audio restoration\nfor vinyl and tape transfers";
            g.drawText (description,
                       centre.x - labelRadius * 0.9f, centre.y - labelRadius * 0.3f,
                       labelRadius * 1.8f, labelRadius * 0.3f,
                       juce::Justification::centred);

            // Features (compact)
            g.setFont (juce::Font (juce::FontOptions (labelRadius * 0.065f)));
            juce::String features = "Click removal • Noise reduction\n"
                                   "Graphic EQ • Track detection\n"
                                   "Wow & flutter • Batch processing";
            g.drawText (features,
                       centre.x - labelRadius * 0.9f, centre.y + labelRadius * 0.05f,
                       labelRadius * 1.8f, labelRadius * 0.4f,
                       juce::Justification::centred);

            // Copyright
            g.setFont (juce::Font (juce::FontOptions (labelRadius * 0.075f)));
            g.drawText ("(c) 2024-2025 flarkAUDIO",
                       centre.x - labelRadius * 0.9f, centre.y + labelRadius * 0.6f,
                       labelRadius * 1.8f, labelRadius * 0.15f,
                       juce::Justification::centred);

            // Close instruction
            g.setColour (juce::Colours::white);
            g.setFont (juce::Font (juce::FontOptions (12.0f)));
            g.drawText ("Click anywhere to close",
                       bounds.getX(), bounds.getBottom() - 30,
                       bounds.getWidth(), 20,
                       juce::Justification::centred);
        }

        void mouseDown (const juce::MouseEvent&) override
        {
            // Check if click is inside the vinyl circle
            auto centre = getLocalBounds().getCentre().toFloat();
            float radius = juce::jmin (getWidth(), getHeight()) / 2.0f;

            // Close dialog
            if (auto* parent = getParentComponent())
                parent->exitModalState (0);
        }

        // Make the component shape circular for proper hit testing
        bool hitTest (int x, int y) override
        {
            auto centre = getLocalBounds().getCentre().toFloat();
            float radius = juce::jmin (getWidth(), getHeight()) / 2.0f;
            float dx = x - centre.x;
            float dy = y - centre.y;
            return (dx * dx + dy * dy) <= (radius * radius);
        }
    };

    // Create modal overlay
    auto* overlay = new juce::Component();
    overlay->setSize (getWidth(), getHeight());
    overlay->setAlwaysOnTop (true);

    // Semi-transparent background
    overlay->setPaintingIsUnclipped (true);
    overlay->setInterceptsMouseClicks (true, true);

    // Custom paint for overlay background
    struct OverlayComponent : public juce::Component
    {
        std::unique_ptr<CircularVinylDialog> vinylDialog;

        OverlayComponent()
        {
            vinylDialog = std::make_unique<CircularVinylDialog>();
            addAndMakeVisible (vinylDialog.get());
        }

        void paint (juce::Graphics& g) override
        {
            // Semi-transparent black background
            g.fillAll (juce::Colours::black.withAlpha (0.7f));
        }

        void resized() override
        {
            // Center the vinyl dialog
            vinylDialog->centreWithSize (400, 400);
        }

        void mouseDown (const juce::MouseEvent& e) override
        {
            // Close if clicking outside the vinyl
            if (!vinylDialog->getBounds().contains (e.getPosition()))
                exitModalState (0);
        }
    };

    auto* overlayComp = new OverlayComponent();
    overlayComp->setSize (getWidth(), getHeight());
    overlayComp->addToDesktop (0);
    overlayComp->enterModalState (true, juce::ModalCallbackFunction::create (
        [overlayComp] (int)
        {
            delete overlayComp;
        }
    ), true);
}

void StandaloneWindow::updateTitle()
{
    juce::String title = "Vinyl Restoration Suite - Standalone";

    if (currentFile.exists())
    {
        title += " - " + currentFile.getFileNameWithoutExtension();
        if (hasUnsavedChanges)
            title += "*";
    }

    setName (title);
}

void StandaloneWindow::showAudioSettings()
{
    // Show JUCE's built-in audio settings dialog
    juce::DialogWindow::LaunchOptions options;
    options.dialogTitle = "Audio Settings";
    options.dialogBackgroundColour = juce::Colours::darkgrey;
    options.content.setOwned (new juce::AudioDeviceSelectorComponent (
        audioDeviceManager,
        0,  // min input channels
        0,  // max input channels
        2,  // min output channels
        2,  // max output channels
        false,  // show MIDI input
        false,  // show MIDI output
        false,  // show channels as stereo pairs
        false   // hide advanced options
    ));
    options.content->setSize (500, 400);
    options.launchAsync();
}

//==============================================================================
// MainComponent Implementation
//==============================================================================

StandaloneWindow::MainComponent::MainComponent()
{
    // Load logo from embedded PNG data
    #include "../Resources/VRSLogoData.h"
    logoImage = juce::ImageFileFormat::loadFrom (VRSlogo_png, VRSlogo_png_len);

    // Add waveform display
    addAndMakeVisible (waveformDisplay);

    // Add correction list
    addAndMakeVisible (correctionListView);

    // Transport controls (retro cassette deck style)
    addAndMakeVisible (rewindButton);
    addAndMakeVisible (playPauseButton);
    addAndMakeVisible (stopButton);
    addAndMakeVisible (forwardButton);

    rewindButton.addListener (this);
    playPauseButton.addListener (this);
    stopButton.addListener (this);
    forwardButton.addListener (this);

    rewindButton.setTooltip ("Skip backward 5 seconds");
    playPauseButton.setTooltip ("Play/Pause playback (Spacebar)");
    stopButton.setTooltip ("Stop playback and return to start");
    forwardButton.setTooltip ("Skip forward 5 seconds");

    // Enable keyboard focus for spacebar control
    setWantsKeyboardFocus (true);

    // Position slider
    addAndMakeVisible (positionSlider);
    positionSlider.setRange (0.0, 1.0);
    positionSlider.setTextBoxStyle (juce::Slider::NoTextBox, false, 0, 0);
    positionSlider.addListener (this);
    positionSlider.setTooltip ("Seek playback position");

    // Time label
    addAndMakeVisible (timeLabel);
    timeLabel.setText ("00:00.000", juce::dontSendNotification);
    timeLabel.setJustificationType (juce::Justification::centred);

    // Volume slider
    addAndMakeVisible (volumeSlider);
    volumeSlider.setRange (0.0, 1.0);
    volumeSlider.setValue (0.7); // 70% default volume
    volumeSlider.setSliderStyle (juce::Slider::LinearVertical);
    volumeSlider.setTextBoxStyle (juce::Slider::NoTextBox, false, 0, 0);
    volumeSlider.addListener (this);
    volumeSlider.setTooltip ("Adjust playback volume (0-100%)");

    // Volume label
    addAndMakeVisible (volumeLabel);
    volumeLabel.setText ("Volume", juce::dontSendNotification);
    volumeLabel.setJustificationType (juce::Justification::centred);

    // Zoom controls
    addAndMakeVisible (zoomInButton);
    addAndMakeVisible (zoomOutButton);
    addAndMakeVisible (zoomFitButton);

    zoomInButton.addListener (this);
    zoomOutButton.addListener (this);
    zoomFitButton.addListener (this);

    zoomInButton.setTooltip ("Zoom in waveform horizontally");
    zoomOutButton.setTooltip ("Zoom out waveform horizontally");
    zoomFitButton.setTooltip ("Fit entire waveform in view");

    // Horizontal zoom slider (below waveform)
    addAndMakeVisible (horizontalZoomSlider);
    horizontalZoomSlider.setRange (1.0, 100.0, 0.1);
    horizontalZoomSlider.setValue (1.0);
    horizontalZoomSlider.setSkewFactorFromMidPoint (10.0);
    horizontalZoomSlider.setSliderStyle (juce::Slider::LinearHorizontal);
    horizontalZoomSlider.setTextBoxStyle (juce::Slider::TextBoxRight, false, 60, 20);
    horizontalZoomSlider.addListener (this);
    horizontalZoomSlider.setTooltip ("Horizontal zoom (1x to 100x)");

    addAndMakeVisible (horizontalZoomLabel);
    horizontalZoomLabel.setText ("H-Zoom:", juce::dontSendNotification);
    horizontalZoomLabel.setJustificationType (juce::Justification::centredRight);

    // Vertical zoom slider (next to waveform)
    addAndMakeVisible (verticalZoomSlider);
    verticalZoomSlider.setRange (0.1, 10.0, 0.1);
    verticalZoomSlider.setValue (1.0);
    verticalZoomSlider.setSkewFactorFromMidPoint (1.0);
    verticalZoomSlider.setSliderStyle (juce::Slider::LinearVertical);
    verticalZoomSlider.setTextBoxStyle (juce::Slider::NoTextBox, false, 0, 0);
    verticalZoomSlider.addListener (this);
    verticalZoomSlider.setTooltip ("Vertical zoom (amplitude)");

    addAndMakeVisible (verticalZoomLabel);
    verticalZoomLabel.setText ("V-Zoom", juce::dontSendNotification);
    verticalZoomLabel.setJustificationType (juce::Justification::centred);

    // Selection editor
    addAndMakeVisible (selectionStartLabel);
    selectionStartLabel.setText ("Start:", juce::dontSendNotification);
    selectionStartLabel.setJustificationType (juce::Justification::centredRight);

    addAndMakeVisible (selectionStartEditor);
    selectionStartEditor.setInputRestrictions (12, "0123456789.:,");
    selectionStartEditor.setTooltip ("Selection start time (mm:ss.ms)");

    addAndMakeVisible (selectionEndLabel);
    selectionEndLabel.setText ("End:", juce::dontSendNotification);
    selectionEndLabel.setJustificationType (juce::Justification::centredRight);

    addAndMakeVisible (selectionEndEditor);
    selectionEndEditor.setInputRestrictions (12, "0123456789.:,");
    selectionEndEditor.setTooltip ("Selection end time (mm:ss.ms)");

    addAndMakeVisible (selectionLengthLabel);
    selectionLengthLabel.setText ("Length: 00:00.000", juce::dontSendNotification);
    selectionLengthLabel.setJustificationType (juce::Justification::centredLeft);

    addAndMakeVisible (clearSelectionButton);
    clearSelectionButton.addListener (this);
    clearSelectionButton.setTooltip ("Clear current selection");

    // Enable keyboard focus for spacebar handling
    setWantsKeyboardFocus (true);

    // Status label
    addAndMakeVisible (statusLabel);
    statusLabel.setText ("Ready", juce::dontSendNotification);
    statusLabel.setJustificationType (juce::Justification::centredLeft);

    // Setup waveform display callbacks
    waveformDisplay.onSelectionChanged = [this] (int64_t start, int64_t end)
    {
        // Update selection editor with start/end/length values
        if (currentBuffer != nullptr && currentSampleRate > 0)
        {
            double startSeconds = start / currentSampleRate;
            double endSeconds = end / currentSampleRate;
            double lengthSeconds = (end - start) / currentSampleRate;

            int startMinutes = (int) (startSeconds / 60.0);
            double startSecs = startSeconds - startMinutes * 60;
            int endMinutes = (int) (endSeconds / 60.0);
            double endSecs = endSeconds - endMinutes * 60;
            int lengthMinutes = (int) (lengthSeconds / 60.0);
            double lengthSecs = lengthSeconds - lengthMinutes * 60;

            selectionStartEditor.setText (juce::String::formatted ("%02d:%06.3f", startMinutes, startSecs), juce::dontSendNotification);
            selectionEndEditor.setText (juce::String::formatted ("%02d:%06.3f", endMinutes, endSecs), juce::dontSendNotification);
            selectionLengthLabel.setText ("Length: " + juce::String::formatted ("%02d:%06.3f", lengthMinutes, lengthSecs), juce::dontSendNotification);
        }
    };
}

StandaloneWindow::MainComponent::~MainComponent()
{
}

void StandaloneWindow::MainComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colour (0xff2e2e2e));

    // Draw logo in bottom-right corner
    if (logoImage.isValid())
    {
        int logoWidth = 200;
        int logoHeight = (int) (logoImage.getHeight() * (logoWidth / (float) logoImage.getWidth()));
        int x = getWidth() - logoWidth - 10;
        int y = getHeight() - logoHeight - 10;
        g.drawImage (logoImage, x, y, logoWidth, logoHeight,
                     0, 0, logoImage.getWidth(), logoImage.getHeight());
    }
}

void StandaloneWindow::MainComponent::resized()
{
    auto area = getLocalBounds();

    // Menu bar at very top (if present)
    for (auto* child : getChildren())
    {
        if (auto* menuBar = dynamic_cast<juce::MenuBarComponent*> (child))
        {
            menuBar->setBounds (area.removeFromTop (juce::LookAndFeel::getDefaultLookAndFeel()
                                                    .getDefaultMenuBarHeight()));
            break;
        }
    }

    // Volume slider uses ENTIRE right side of window (80px wide)
    auto volumeArea = area.removeFromRight (80);
    volumeArea.reduce (10, 10);

    // Volume label at top of volume area
    auto volumeLabelArea = volumeArea.removeFromTop (60);
    volumeLabel.setBounds (volumeLabelArea);

    // Volume slider fills remaining vertical space
    volumeSlider.setBounds (volumeArea);

    // Left side contains all other content
    area.removeFromRight (5); // spacing

    // Transport controls at top (cassette deck style)
    auto transportArea = area.removeFromTop (50);
    transportArea.reduce (10, 10);

    rewindButton.setBounds (transportArea.removeFromLeft (50));
    transportArea.removeFromLeft (5);
    playPauseButton.setBounds (transportArea.removeFromLeft (80));  // Wider for toggle button
    transportArea.removeFromLeft (5);
    stopButton.setBounds (transportArea.removeFromLeft (60));
    transportArea.removeFromLeft (5);
    forwardButton.setBounds (transportArea.removeFromLeft (50));
    transportArea.removeFromLeft (10);

    // Time label and position slider
    timeLabel.setBounds (transportArea.removeFromRight (100));
    transportArea.removeFromRight (10);
    positionSlider.setBounds (transportArea);

    // Waveform area with vertical zoom slider on left
    auto waveformHeight = (int) (area.getHeight() * 0.66f);
    auto waveformArea = area.removeFromTop (waveformHeight);

    // Vertical zoom slider on left side of waveform
    auto vZoomArea = waveformArea.removeFromLeft (50);
    vZoomArea.reduce (5, 10);

    verticalZoomLabel.setBounds (vZoomArea.removeFromTop (50));
    verticalZoomSlider.setBounds (vZoomArea);

    waveformArea.removeFromLeft (5); // Small gap
    waveformDisplay.setBounds (waveformArea);

    area.removeFromTop (5); // Small gap

    // Zoom buttons + horizontal zoom slider directly under waveform (same row)
    auto zoomButtonArea = area.removeFromTop (40);
    zoomButtonArea.reduce (10, 5);

    zoomInButton.setBounds (zoomButtonArea.removeFromLeft (40));
    zoomButtonArea.removeFromLeft (5);
    zoomOutButton.setBounds (zoomButtonArea.removeFromLeft (40));
    zoomButtonArea.removeFromLeft (5);
    zoomFitButton.setBounds (zoomButtonArea.removeFromLeft (60));
    zoomButtonArea.removeFromLeft (10);

    // Horizontal zoom slider on same row as buttons
    horizontalZoomLabel.setBounds (zoomButtonArea.removeFromLeft (60));
    zoomButtonArea.removeFromLeft (5);
    horizontalZoomSlider.setBounds (zoomButtonArea);

    area.removeFromTop (5); // Small gap

    // Selection editor directly under zoom buttons
    auto selectionArea = area.removeFromTop (35);
    selectionArea.reduce (10, 5);

    selectionStartLabel.setBounds (selectionArea.removeFromLeft (45));
    selectionArea.removeFromLeft (3);
    selectionStartEditor.setBounds (selectionArea.removeFromLeft (85));
    selectionArea.removeFromLeft (10);

    selectionEndLabel.setBounds (selectionArea.removeFromLeft (35));
    selectionArea.removeFromLeft (3);
    selectionEndEditor.setBounds (selectionArea.removeFromLeft (85));
    selectionArea.removeFromLeft (10);

    selectionLengthLabel.setBounds (selectionArea.removeFromLeft (150));
    selectionArea.removeFromLeft (10);

    clearSelectionButton.setBounds (selectionArea.removeFromLeft (60));

    area.removeFromTop (5); // Small gap

    // Status bar just above correction list
    auto statusArea = area.removeFromBottom (30);
    statusArea.reduce (10, 5);
    statusLabel.setBounds (statusArea);

    // Correction list takes remaining space
    correctionListView.setBounds (area);
}

void StandaloneWindow::MainComponent::buttonClicked (juce::Button* button)
{
    if (button == &playPauseButton)
    {
        if (parentWindow && parentWindow->transportSource.getTotalLength() > 0.0)
        {
            if (parentWindow->isPlaying)
            {
                // Pause
                parentWindow->transportSource.stop();
                parentWindow->isPlaying = false;
                playPauseButton.setButtonText ("Play");
                DBG ("Playback paused");
            }
            else
            {
                // Play/Resume
                parentWindow->transportSource.start();
                parentWindow->isPlaying = true;
                playPauseButton.setButtonText ("Pause");
                DBG ("Playback started");
            }
        }
    }
    else if (button == &stopButton)
    {
        if (parentWindow)
        {
            parentWindow->transportSource.stop();
            parentWindow->transportSource.setPosition (0.0);
            parentWindow->isPlaying = false;
            playPauseButton.setButtonText ("Play");
            DBG ("Playback stopped");
        }
    }
    else if (button == &rewindButton)
    {
        // Skip backward 5 seconds
        if (parentWindow && parentWindow->transportSource.getTotalLength() > 0.0)
        {
            double currentPos = parentWindow->transportSource.getCurrentPosition();
            double newPos = juce::jmax (0.0, currentPos - 5.0);
            parentWindow->transportSource.setPosition (newPos);
            DBG ("Rewound to: " + juce::String (newPos, 2) + "s");
        }
    }
    else if (button == &forwardButton)
    {
        // Skip forward 5 seconds
        if (parentWindow && parentWindow->transportSource.getTotalLength() > 0.0)
        {
            double currentPos = parentWindow->transportSource.getCurrentPosition();
            double totalLength = parentWindow->transportSource.getLengthInSeconds();
            double newPos = juce::jmin (totalLength, currentPos + 5.0);
            parentWindow->transportSource.setPosition (newPos);
            DBG ("Fast-forwarded to: " + juce::String (newPos, 2) + "s");
        }
    }
    else if (button == &zoomInButton)
    {
        // Zoom in = increase zoom multiplier
        double newZoom = waveformDisplay.horizontalZoom * 2.0;
        waveformDisplay.setHorizontalZoom (newZoom);
        horizontalZoomSlider.setValue (newZoom, juce::dontSendNotification);
    }
    else if (button == &zoomOutButton)
    {
        // Zoom out = decrease zoom multiplier
        double newZoom = juce::jmax (1.0, waveformDisplay.horizontalZoom * 0.5);
        waveformDisplay.setHorizontalZoom (newZoom);
        horizontalZoomSlider.setValue (newZoom, juce::dontSendNotification);
    }
    else if (button == &zoomFitButton)
    {
        // Fit entire waveform
        waveformDisplay.setHorizontalZoom (1.0);
        waveformDisplay.scrollPosition = 0.0;
        horizontalZoomSlider.setValue (1.0, juce::dontSendNotification);
    }
    else if (button == &clearSelectionButton)
    {
        // Clear waveform selection
        waveformDisplay.clearSelection();

        selectionStartEditor.setText ("");
        selectionEndEditor.setText ("");
        selectionLengthLabel.setText ("Length: 00:00.000", juce::dontSendNotification);

        DBG ("Selection cleared");
    }
}

void StandaloneWindow::MainComponent::sliderValueChanged (juce::Slider* slider)
{
    if (slider == &positionSlider)
    {
        double position = positionSlider.getValue();
        waveformDisplay.setPlaybackPosition (position);

        // Instant seek: update transport source position (even during playback)
        if (parentWindow && currentBuffer != nullptr)
        {
            double timeInSeconds = position * (currentBuffer->getNumSamples() / currentSampleRate);
            parentWindow->transportSource.setPosition (timeInSeconds);

            // Update time label
            int minutes = (int) (timeInSeconds / 60.0);
            double seconds = timeInSeconds - minutes * 60;
            juce::String timeString = juce::String::formatted ("%02d:%06.3f", minutes, seconds);
            timeLabel.setText (timeString, juce::dontSendNotification);
        }
    }
    else if (slider == &volumeSlider)
    {
        // Update volume
        float volume = (float) volumeSlider.getValue();
        if (parentWindow)
        {
            parentWindow->transportSource.setGain (volume);
            DBG ("Volume set to: " + juce::String (volume * 100.0f, 0) + "%");
        }
    }
    else if (slider == &horizontalZoomSlider)
    {
        // Update horizontal zoom
        double zoomValue = horizontalZoomSlider.getValue();
        waveformDisplay.setHorizontalZoom (zoomValue);
        DBG ("Horizontal zoom: " + juce::String (zoomValue, 1) + "x");
    }
    else if (slider == &verticalZoomSlider)
    {
        // Update vertical zoom
        double zoomValue = verticalZoomSlider.getValue();
        waveformDisplay.setVerticalZoom (zoomValue);
        DBG ("Vertical zoom: " + juce::String (zoomValue, 1) + "x");
    }
}

bool StandaloneWindow::MainComponent::keyPressed (const juce::KeyPress& key)
{
    // Spacebar toggles play/pause
    if (key == juce::KeyPress::spaceKey)
    {
        if (parentWindow && parentWindow->currentFile.exists())
        {
            if (parentWindow->isPlaying)
            {
                // Pause playback
                parentWindow->transportSource.stop();
                parentWindow->isPlaying = false;
                playPauseButton.setButtonText ("Play");
                DBG ("Playback paused (spacebar)");
            }
            else
            {
                // Start/resume playback
                parentWindow->transportSource.start();
                parentWindow->isPlaying = true;
                playPauseButton.setButtonText ("Pause");
                DBG ("Playback started (spacebar)");
            }
            return true; // Key was handled
        }
    }

    return false; // Key not handled
}

void StandaloneWindow::MainComponent::mouseWheelMove (const juce::MouseEvent& event, const juce::MouseWheelDetails& wheel)
{
    // Mouse wheel scrubbing on position slider area
    if (positionSlider.getBounds().contains (event.getPosition()) && parentWindow && currentBuffer != nullptr)
    {
        double currentPos = positionSlider.getValue();
        double delta = wheel.deltaY * 0.01;  // Scroll sensitivity
        double newPos = juce::jlimit (0.0, 1.0, currentPos + delta);

        positionSlider.setValue (newPos, juce::sendNotificationSync);

        // The slider value changed handler will update the transport position
        event.source.enableUnboundedMouseMovement (false);
    }
}

void StandaloneWindow::MainComponent::setAudioBuffer (const juce::AudioBuffer<float>* buffer, double sampleRate)
{
    currentBuffer = buffer;
    currentSampleRate = sampleRate;

    if (buffer != nullptr)
    {
        statusLabel.setText (juce::String (buffer->getNumChannels()) + " channels, " +
                           juce::String (sampleRate / 1000.0, 1) + " kHz, " +
                           juce::String (buffer->getNumSamples() / sampleRate, 2) + " seconds",
                           juce::dontSendNotification);

        // Grab keyboard focus so spacebar works immediately after loading
        grabKeyboardFocus();
    }
}

void StandaloneWindow::MainComponent::updatePlaybackPosition (double position)
{
    positionSlider.setValue (position, juce::dontSendNotification);
    waveformDisplay.setPlaybackPosition (position);
}
