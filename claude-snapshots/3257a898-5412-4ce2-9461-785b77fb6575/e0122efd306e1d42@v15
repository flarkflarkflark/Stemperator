#include "StandaloneWindow.h"

//==============================================================================
// StandaloneWindow Implementation
//==============================================================================

StandaloneWindow::StandaloneWindow()
    : DocumentWindow ("Vinyl Restoration Suite",
                      juce::Colour (0xff2e2e2e),
                      DocumentWindow::allButtons),
      menuBar (this)
{
    setUsingNativeTitleBar (true);
    setResizable (true, true);

    // Initialize audio device
    juce::String audioError = audioDeviceManager.initialise (
        0,     // number of input channels
        2,     // number of output channels
        nullptr,  // saved state
        true   // select default device on failure
    );

    if (audioError.isNotEmpty())
    {
        DBG ("Audio device error: " + audioError);
    }

    // Setup audio transport
    transportSource.addChangeListener (this);
    audioSourcePlayer.setSource (&transportSource);
    audioDeviceManager.addAudioCallback (&audioSourcePlayer);

    // Create main component
    mainComponent = std::make_unique<MainComponent>();
    mainComponent->setParentWindow (this);

    // Wire up waveform double-click to seek playback
    mainComponent->getWaveformDisplay().onSeekPosition = [this](double position)
    {
        if (transportSource.getTotalLength() > 0.0)
        {
            double timeInSeconds = position * transportSource.getLengthInSeconds();
            transportSource.setPosition (timeInSeconds);
            DBG ("Seek to: " + juce::String (timeInSeconds) + " seconds");
        }
    };

    // Add menu bar to main component using base class method
    mainComponent->Component::addAndMakeVisible (menuBar);

    // Create scaled content wrapper
    contentWrapper = std::make_unique<ScaledContentWrapper> (mainComponent.get(), baseWidth, baseHeight);
    setContentNonOwned (contentWrapper.get(), true);

    // Set initial size
    centreWithSize (1200, 800);

    // Load recent files
    recentFiles.setMaxNumberOfItems (10);

    // Load recent files from settings
    auto settingsFile = juce::File::getSpecialLocation (juce::File::userApplicationDataDirectory)
                            .getChildFile ("VinylRestorationSuite")
                            .getChildFile ("recent_files.txt");
    if (settingsFile.existsAsFile())
    {
        recentFiles.restoreFromString (settingsFile.loadFileAsString());
        DBG ("Loaded " + juce::String (recentFiles.getNumFiles()) + " recent files");
    }

    // Start timer for playback position updates
    startTimer (40); // 25 fps

    setVisible (true);
}

StandaloneWindow::~StandaloneWindow()
{
    // Save recent files to settings
    auto settingsDir = juce::File::getSpecialLocation (juce::File::userApplicationDataDirectory)
                           .getChildFile ("VinylRestorationSuite");
    settingsDir.createDirectory();
    auto settingsFile = settingsDir.getChildFile ("recent_files.txt");
    settingsFile.replaceWithText (recentFiles.toString());
    DBG ("Saved " + juce::String (recentFiles.getNumFiles()) + " recent files");

    // Stop audio playback
    transportSource.setSource (nullptr);
    audioSourcePlayer.setSource (nullptr);
    audioDeviceManager.removeAudioCallback (&audioSourcePlayer);
    transportSource.removeChangeListener (this);

    setMenuBar (nullptr);
}

void StandaloneWindow::closeButtonPressed()
{
    if (hasUnsavedChanges)
    {
        int result = juce::AlertWindow::showYesNoCancelBox (
            juce::AlertWindow::QuestionIcon,
            "Unsaved Changes",
            "Do you want to save your changes before closing?",
            "Save", "Don't Save", "Cancel",
            nullptr, nullptr
        );

        if (result == 0) // Cancel
            return;
        else if (result == 1) // Save
        {
            if (currentFile.exists())
            {
                saveFile (currentFile);
            }
            else
            {
                // No file exists, show save dialog
                exportFile();
                return; // exportFile is async, will handle quit after save
            }
        }
        // result == 2 means "Don't Save" - fall through to quit
    }

    juce::JUCEApplication::getInstance()->systemRequestedQuit();
}

//==============================================================================
// Drag and Drop
//==============================================================================

bool StandaloneWindow::isInterestedInFileDrag (const juce::StringArray& files)
{
    for (const auto& file : files)
    {
        juce::File f (file);
        if (f.hasFileExtension ("wav;flac;aiff;mp3;ogg"))
            return true;
    }
    return false;
}

void StandaloneWindow::filesDropped (const juce::StringArray& files, int, int)
{
    if (files.size() > 0)
    {
        juce::File file (files[0]);
        openFile (file);
    }
}

//==============================================================================
// Menu Bar
//==============================================================================

juce::StringArray StandaloneWindow::getMenuBarNames()
{
    return {"File", "Edit", "Process", "View", "Options", "Help"};
}

juce::PopupMenu StandaloneWindow::getMenuForIndex (int topLevelMenuIndex, const juce::String&)
{
    juce::PopupMenu menu;

    if (topLevelMenuIndex == 0) // File
    {
        menu.addItem (fileOpen, "Open...                   Ctrl+O");
        menu.addItem (fileClose, "Close File                Ctrl+W", currentFile.exists());
        menu.addSeparator();
        menu.addItem (fileSave, "Save                      Ctrl+S", currentFile.exists());
        menu.addItem (fileSaveAs, "Save As...             Ctrl+Shift+S");
        menu.addSeparator();
        menu.addItem (fileExport, "Export Audio...           Ctrl+E", audioBuffer.getNumSamples() > 0);
        menu.addSeparator();

        // Recent files submenu
        juce::PopupMenu recentMenu;
        recentFiles.createPopupMenuItems (recentMenu, 100, true, true);
        menu.addSubMenu ("Recent Files", recentMenu);
        menu.addItem (fileRecentClear, "Clear Recent Files");

        menu.addSeparator();
        menu.addItem (fileExit, "Exit                      Ctrl+Q");
    }
    else if (topLevelMenuIndex == 1) // Edit
    {
        menu.addItem (editUndo, "Undo                      Ctrl+Z", false);
        menu.addItem (editRedo, "Redo                      Ctrl+Y", false);
        menu.addSeparator();
        menu.addItem (editSelectAll, "Select All                Ctrl+A", false);
        menu.addItem (editDeselect, "Deselect                  Ctrl+D", false);
    }
    else if (topLevelMenuIndex == 2) // Process
    {
        bool hasAudio = audioBuffer.getNumSamples() > 0;
        menu.addItem (processDetectClicks, "Detect Clicks", hasAudio);
        menu.addItem (processRemoveClicks, "Remove Clicks", hasAudio);
        menu.addSeparator();
        menu.addItem (processNoiseReduction, "Noise Reduction...", hasAudio);
        menu.addSeparator();
        menu.addItem (processCutAndSplice, "Cut and Splice...", hasAudio);
        menu.addSeparator();
        menu.addItem (processGraphicEQ, "Graphic Equaliser...", hasAudio);
        menu.addSeparator();
        menu.addItem (processNormalise, "Normalise...", hasAudio);
        menu.addItem (processChannelBalance, "Channel Balance...", hasAudio);
        menu.addSeparator();
        menu.addItem (processWowFlutterRemoval, "Wow & Flutter Removal...", hasAudio);
        menu.addItem (processDropoutRestoration, "Dropout Restoration...", hasAudio);
        menu.addItem (processSpeedCorrection, "Speed Correction...", hasAudio);
        menu.addSeparator();
        menu.addItem (processDetectTracks, "Detect Tracks", hasAudio);
        menu.addItem (processSplitTracks, "Split Tracks...", hasAudio);
        menu.addSeparator();
        menu.addItem (processBatchProcess, "Batch Process...");
    }
    else if (topLevelMenuIndex == 3) // View
    {
        menu.addItem (viewZoomIn, "Zoom In                   Ctrl++");
        menu.addItem (viewZoomOut, "Zoom Out                  Ctrl+-");
        menu.addItem (viewZoomFit, "Zoom to Fit               Ctrl+0");
        menu.addSeparator();

        // UI Scale submenu
        juce::PopupMenu scaleMenu;
        scaleMenu.addItem (viewScale25, "25%", true, uiScaleFactor == 0.25f);
        scaleMenu.addItem (viewScale50, "50%", true, uiScaleFactor == 0.50f);
        scaleMenu.addItem (viewScale75, "75%", true, uiScaleFactor == 0.75f);
        scaleMenu.addItem (viewScale100, "100%", true, uiScaleFactor == 1.00f);
        scaleMenu.addItem (viewScale125, "125%", true, uiScaleFactor == 1.25f);
        scaleMenu.addItem (viewScale150, "150%", true, uiScaleFactor == 1.50f);
        scaleMenu.addItem (viewScale200, "200%", true, uiScaleFactor == 2.00f);
        scaleMenu.addItem (viewScale300, "300%", true, uiScaleFactor == 3.00f);
        scaleMenu.addItem (viewScale400, "400%", true, uiScaleFactor == 4.00f);
        menu.addSubMenu ("UI Scale", scaleMenu);

        menu.addSeparator();
        menu.addItem (viewShowCorrectionList, "Show Correction List", true, true);
    }
    else if (topLevelMenuIndex == 4) // Options
    {
        menu.addItem (optionsAudioSettings, "Audio Settings...");
    }
    else if (topLevelMenuIndex == 5) // Help
    {
        menu.addItem (helpAbout, "About");
        menu.addItem (helpDocumentation, "Documentation", false);
    }

    return menu;
}

void StandaloneWindow::menuItemSelected (int menuItemID, int)
{
    // Handle recent files
    if (menuItemID >= 100 && menuItemID < 200)
    {
        juce::File file = recentFiles.getFile (menuItemID - 100);
        if (file.exists())
            openFile (file);
        return;
    }

    // Handle menu commands
    switch (menuItemID)
    {
        case fileOpen:
        {
            auto chooser = std::make_shared<juce::FileChooser> ("Open Audio File or Session",
                                       juce::File::getSpecialLocation (juce::File::userHomeDirectory),
                                       "*.wav;*.flac;*.aiff;*.ogg;*.mp3;*.vrs");

            chooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
                [this, chooser] (const juce::FileChooser&)
                {
                    auto file = chooser->getResult();
                    if (file.existsAsFile())
                    {
                        if (file.hasFileExtension ("vrs"))
                            loadSession (file);
                        else
                            openFile (file);
                    }
                });
            break;
        }

        case fileClose:
            closeFile();
            break;

        case fileSave:
            if (currentFile.exists())
                saveFile (currentFile);
            break;

        case fileSaveAs:
        {
            auto chooser = std::make_shared<juce::FileChooser> ("Save Session",
                                       juce::File::getSpecialLocation (juce::File::userHomeDirectory),
                                       "*.vrs");

            chooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
                [this, chooser] (const juce::FileChooser&)
                {
                    auto file = chooser->getResult();
                    if (file != juce::File())
                        saveFile (file);
                });
            break;
        }

        case fileExport:
            exportFile();
            break;

        case fileRecentClear:
            recentFiles.clear();
            menuItemsChanged();
            break;

        case fileExit:
            juce::JUCEApplication::getInstance()->systemRequestedQuit();
            break;

        case processDetectClicks:
            detectClicks();
            break;

        case processRemoveClicks:
            removeClicks();
            break;

        case processNoiseReduction:
            applyNoiseReduction();
            break;

        case processDetectTracks:
            detectTracks();
            break;

        case processSplitTracks:
            splitTracks();
            break;

        case processBatchProcess:
            showBatchProcessor();
            break;

        case optionsAudioSettings:
            showAudioSettings();
            break;

        case helpAbout:
            showAboutDialog();
            break;

        // UI Scale options
        case viewScale25:  setUIScale (0.25f); break;
        case viewScale50:  setUIScale (0.50f); break;
        case viewScale75:  setUIScale (0.75f); break;
        case viewScale100: setUIScale (1.00f); break;
        case viewScale125: setUIScale (1.25f); break;
        case viewScale150: setUIScale (1.50f); break;
        case viewScale200: setUIScale (2.00f); break;
        case viewScale300: setUIScale (3.00f); break;
        case viewScale400: setUIScale (4.00f); break;

        default:
            break;
    }
}

//==============================================================================
// Timer callback
//==============================================================================

void StandaloneWindow::timerCallback()
{
    // Update playback position if playing
    if (transportSource.isPlaying())
    {
        double position = transportSource.getCurrentPosition() / transportSource.getLengthInSeconds();
        mainComponent->updatePlaybackPosition (position);
    }
}

void StandaloneWindow::changeListenerCallback (juce::ChangeBroadcaster*)
{
    // Transport state changed (started/stopped)
    if (transportSource.hasStreamFinished())
    {
        transportSource.setPosition (0.0);
        isPlaying = false;
    }
}

//==============================================================================
// Helper Methods
//==============================================================================

void StandaloneWindow::openFile (const juce::File& file)
{
    if (!file.exists())
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "File Not Found",
                                                "The selected file does not exist.");
        return;
    }

    auto fileSizeMB = file.getSize() / (1024.0 * 1024.0);

    // For large files (>50MB), use progress dialog
    if (fileSizeMB > 50.0)
    {
        openFileWithProgress (file);
        return;
    }

    // For smaller files, load directly with status update
    mainComponent->getCorrectionListView().setStatusText (
        "Loading " + file.getFileName() + " (" +
        juce::String (fileSizeMB, 1) + " MB)..."
    );

    // Load audio file
    if (fileManager.loadAudioFile (file, audioBuffer, sampleRate))
    {
        finishFileLoad (file);
    }
    else
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Error",
                                                "Failed to load audio file.");
        mainComponent->getCorrectionListView().setStatusText ("Ready");
    }
}

void StandaloneWindow::openFileWithProgress (const juce::File& file)
{
    // Show loading status with file info
    auto fileSizeMB = file.getSize() / (1024.0 * 1024.0);
    mainComponent->getCorrectionListView().setStatusText (
        "Loading " + file.getFileName() + " (" +
        juce::String (fileSizeMB, 1) + " MB)..."
    );

    // Force repaint to show status
    mainComponent->getCorrectionListView().repaint();

    loadingProgress = 0.0;
    loadingFile = file;

    // Track last update time for throttling
    auto lastUpdateTime = juce::Time::getMillisecondCounter();

    // Load with progress updates to status bar
    bool success = fileManager.loadAudioFileWithProgress (
        file, audioBuffer, sampleRate,
        [this, &lastUpdateTime] (double prog, const juce::String&) -> bool
        {
            loadingProgress = prog;

            // Throttle UI updates to every 100ms
            auto now = juce::Time::getMillisecondCounter();
            if (now - lastUpdateTime > 100)
            {
                lastUpdateTime = now;
                int percent = static_cast<int> (prog * 100.0);
                mainComponent->getCorrectionListView().setStatusText (
                    "Loading... " + juce::String (percent) + "%"
                );
                mainComponent->getCorrectionListView().repaint();
            }

            return true;  // Continue loading
        }
    );

    if (success)
    {
        finishFileLoad (file);
    }
    else
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Error",
                                                "Failed to load audio file.");
        mainComponent->getCorrectionListView().setStatusText ("Ready");
    }
}

void StandaloneWindow::finishFileLoad (const juce::File& file)
{
    currentFile = file;
    recentFiles.addFile (file);

    // Update waveform display
    mainComponent->getWaveformDisplay().loadFile (file);
    mainComponent->setAudioBuffer (&audioBuffer, sampleRate);

    // Load into transport source for playback
    juce::AudioFormatManager formatManager;
    formatManager.registerBasicFormats();
    formatManager.registerFormat (new juce::FlacAudioFormat(), true);
    formatManager.registerFormat (new juce::OggVorbisAudioFormat(), true);

    #if JUCE_USE_MP3AUDIOFORMAT
    formatManager.registerFormat (new juce::MP3AudioFormat(), true);
    #endif

    auto* reader = formatManager.createReaderFor (file);

    if (reader != nullptr)
    {
        readerSource.reset (new juce::AudioFormatReaderSource (reader, true));
        transportSource.setSource (readerSource.get(), 0, nullptr, reader->sampleRate);
    }

    // Clear corrections
    mainComponent->getCorrectionListView().clearCorrections();

    hasUnsavedChanges = false;
    updateTitle();

    DBG ("Opened file: " + file.getFullPathName());

    auto durationSec = audioBuffer.getNumSamples() / sampleRate;
    juce::String status = "Loaded: " + juce::String (durationSec / 60.0, 1) + " min, " +
                          juce::String (sampleRate / 1000.0, 1) + " kHz";
    mainComponent->getCorrectionListView().setStatusText (status);
}


void StandaloneWindow::closeFile()
{
    // Stop playback
    transportSource.stop();
    transportSource.setSource (nullptr);
    readerSource.reset();
    isPlaying = false;

    // Clear audio buffer
    audioBuffer.setSize (0, 0);
    currentFile = juce::File();

    // Clear displays
    mainComponent->getWaveformDisplay().clear();
    mainComponent->getCorrectionListView().clearCorrections();
    mainComponent->setAudioBuffer (nullptr, sampleRate);

    // Reset state
    hasUnsavedChanges = false;
    updateTitle();

    mainComponent->getCorrectionListView().setStatusText ("No file loaded");
    DBG ("Closed file");
}

void StandaloneWindow::saveFile (const juce::File& file)
{
    // Save session (corrections, settings, etc.)
    juce::var sessionData;
    // TODO: Build session data from current state

    if (fileManager.saveSession (file, currentFile, sessionData))
    {
        hasUnsavedChanges = false;
        updateTitle();
        DBG ("Saved session: " + file.getFullPathName());
    }
    else
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Save Failed",
                                                "Failed to save session file.");
    }
}

void StandaloneWindow::exportFile()
{
    auto chooser = std::make_shared<juce::FileChooser> ("Export Audio",
                               currentFile.getParentDirectory(),
                               "*.wav;*.flac;*.ogg");

    chooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
        [this, chooser] (const juce::FileChooser&)
        {
            juce::File outputFile = chooser->getResult();

            if (outputFile != juce::File())
            {
                if (fileManager.saveAudioFile (outputFile, audioBuffer, sampleRate, 24))
                {
                    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                                            "Export Complete",
                                                            "Audio exported successfully.");
                }
                else
                {
                    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                            "Export Failed",
                                                            "Failed to export audio file.");
                }
            }
        });
}

void StandaloneWindow::detectClicks()
{
    if (audioBuffer.getNumSamples() == 0)
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "No Audio",
                                                "Please load an audio file first.");
        return;
    }

    // Check if there's a selection - if so, only detect in selection
    auto& waveform = mainComponent->getWaveformDisplay();
    int64_t selStart = -1, selEnd = -1;
    waveform.getSelection (selStart, selEnd);

    int scanStart = 0;
    int scanEnd = audioBuffer.getNumSamples();
    juce::String rangeInfo = "whole file";

    if (selStart >= 0 && selEnd > selStart)
    {
        scanStart = static_cast<int> (selStart);
        scanEnd = static_cast<int> (juce::jmin (selEnd, (int64_t) audioBuffer.getNumSamples()));
        double startSec = scanStart / sampleRate;
        double endSec = scanEnd / sampleRate;
        rangeInfo = juce::String (startSec, 2) + "s - " + juce::String (endSec, 2) + "s";
    }

    mainComponent->getCorrectionListView().setStatusText ("Detecting clicks in " + rangeInfo + "...");
    DBG ("Starting click detection on " + juce::String (scanEnd - scanStart) + " samples (" + rangeInfo + ")");

    // Configure click detection
    juce::dsp::ProcessSpec spec;
    spec.sampleRate = sampleRate;
    spec.numChannels = static_cast<juce::uint32> (audioBuffer.getNumChannels());
    spec.maximumBlockSize = 2048;

    clickRemovalProcessor.prepare (spec);
    clickRemovalProcessor.reset();  // Clear previous detections
    clickRemovalProcessor.setSensitivity (60.0f);  // Slightly higher sensitivity for better detection
    clickRemovalProcessor.setStoreDetectedClicks (true);  // IMPORTANT: Store clicks for GUI display
    clickRemovalProcessor.setApplyRemoval (false);  // Detection only - don't modify audio
    clickRemovalProcessor.resetSamplePosition();   // Reset position counter
    clickRemovalProcessor.setSampleOffset (scanStart);  // Set offset for correct position reporting

    // Create a copy of the buffer for detection (non-destructive scan)
    juce::AudioBuffer<float> scanBuffer;
    scanBuffer.makeCopyOf (audioBuffer);

    // Process in blocks to detect clicks
    const int blockSize = 2048;
    int totalClicks = 0;
    int totalSamples = scanEnd - scanStart;
    int lastProgressPercent = 0;

    for (int startSample = scanStart; startSample < scanEnd; startSample += blockSize)
    {
        int samplesThisBlock = juce::jmin (blockSize, scanEnd - startSample);

        juce::dsp::AudioBlock<float> block (scanBuffer.getArrayOfWritePointers(),
                                            static_cast<size_t> (scanBuffer.getNumChannels()),
                                            static_cast<size_t> (startSample),
                                            static_cast<size_t> (samplesThisBlock));

        juce::dsp::ProcessContextReplacing<float> context (block);
        clickRemovalProcessor.process (context);

        totalClicks += clickRemovalProcessor.getClicksDetectedLastBlock();

        // Update progress every 5%
        int currentPercent = (int) (100.0 * (startSample - scanStart) / (double) totalSamples);
        if (currentPercent >= lastProgressPercent + 5)
        {
            lastProgressPercent = currentPercent;
            mainComponent->getCorrectionListView().setStatusText (
                "Detecting clicks... " + juce::String (currentPercent) + "% (" +
                juce::String (totalClicks) + " found)");
            repaint();
        }
    }

    DBG ("Total clicks detected during scan: " + juce::String (totalClicks));

    // Get detected clicks and add to correction list
    const auto& detectedClicks = clickRemovalProcessor.getDetectedClicks();

    DBG ("Clicks stored in vector: " + juce::String (detectedClicks.size()));

    mainComponent->getCorrectionListView().clearCorrections();
    mainComponent->getWaveformDisplay().clearClickMarkers();

    for (const auto& click : detectedClicks)
    {
        mainComponent->getCorrectionListView().addCorrection (
            click.position,
            click.magnitude,
            click.width,
            click.isManual ? "Manual" : "Auto",
            false
        );

        // Add marker to waveform display
        mainComponent->getWaveformDisplay().addClickMarker (click.position);
    }

    if (!detectedClicks.empty())
        hasUnsavedChanges = true;

    updateTitle();

    juce::String message = "Detected " + juce::String (detectedClicks.size()) + " clicks/pops.";
    mainComponent->getCorrectionListView().setStatusText (message);

    if (detectedClicks.empty())
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                                "Click Detection Complete",
                                                "No clicks or pops detected in the audio.\n\n"
                                                "The audio appears to be clean, or try adjusting sensitivity.");
    }
    else
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                                "Click Detection Complete",
                                                message + "\n\nUse 'Process > Remove Clicks' to apply corrections.");
    }
}

void StandaloneWindow::removeClicks()
{
    if (audioBuffer.getNumSamples() == 0)
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "No Audio",
                                                "Please load an audio file first.");
        return;
    }

    mainComponent->getCorrectionListView().setStatusText ("Removing clicks...");
    DBG ("Starting click removal on " + juce::String (audioBuffer.getNumSamples()) + " samples");

    // Configure click removal processor
    juce::dsp::ProcessSpec spec;
    spec.sampleRate = sampleRate;
    spec.numChannels = static_cast<juce::uint32> (audioBuffer.getNumChannels());
    spec.maximumBlockSize = 2048;

    clickRemovalProcessor.prepare (spec);
    clickRemovalProcessor.reset();
    clickRemovalProcessor.setSensitivity (60.0f);
    clickRemovalProcessor.setRemovalMethod (ClickRemoval::Automatic);
    clickRemovalProcessor.setStoreDetectedClicks (false);  // Don't need to store, just remove
    clickRemovalProcessor.setApplyRemoval (true);  // Actually remove the clicks
    clickRemovalProcessor.resetSamplePosition();

    // Process the actual audio buffer (destructive operation)
    const int blockSize = 2048;
    int totalClicksRemoved = 0;

    for (int startSample = 0; startSample < audioBuffer.getNumSamples(); startSample += blockSize)
    {
        int samplesThisBlock = juce::jmin (blockSize, audioBuffer.getNumSamples() - startSample);

        juce::dsp::AudioBlock<float> block (audioBuffer.getArrayOfWritePointers(),
                                            static_cast<size_t> (audioBuffer.getNumChannels()),
                                            static_cast<size_t> (startSample),
                                            static_cast<size_t> (samplesThisBlock));

        juce::dsp::ProcessContextReplacing<float> context (block);
        clickRemovalProcessor.process (context);

        totalClicksRemoved += clickRemovalProcessor.getClicksDetectedLastBlock();
    }

    DBG ("Total clicks removed: " + juce::String (totalClicksRemoved));

    // Mark corrections as applied in the list
    mainComponent->getCorrectionListView().markAllApplied();

    // Update waveform display to show processed audio
    mainComponent->getWaveformDisplay().updateFromBuffer (audioBuffer, sampleRate);

    hasUnsavedChanges = true;
    updateTitle();

    juce::String message = "Removed " + juce::String (totalClicksRemoved) + " clicks/pops.";
    mainComponent->getCorrectionListView().setStatusText (message);

    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Click Removal Complete",
                                            message);
}

void StandaloneWindow::applyNoiseReduction()
{
    if (audioBuffer.getNumSamples() == 0)
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "No Audio",
                                                "Please load an audio file first.");
        return;
    }

    // Create noise reduction settings dialog
    auto* dialog = new juce::AlertWindow ("Noise Reduction Settings",
                                          "Configure noise reduction parameters:",
                                          juce::AlertWindow::QuestionIcon);

    dialog->addTextEditor ("reduction", "12", "Reduction Amount (dB):");
    dialog->addTextEditor ("profileStart", "0", "Profile Start (seconds):");
    dialog->addTextEditor ("profileLength", "1", "Profile Length (seconds):");

    dialog->addButton ("Apply", 1);
    dialog->addButton ("Cancel", 0);

    dialog->enterModalState (true, juce::ModalCallbackFunction::create (
        [this, dialog] (int result)
        {
            if (result == 1)
            {
                float reductionDB = dialog->getTextEditorContents ("reduction").getFloatValue();
                float profileStart = dialog->getTextEditorContents ("profileStart").getFloatValue();
                float profileLength = dialog->getTextEditorContents ("profileLength").getFloatValue();

                reductionDB = juce::jlimit (0.0f, 24.0f, reductionDB);
                profileStart = juce::jmax (0.0f, profileStart);
                profileLength = juce::jmax (0.1f, profileLength);

                // Apply noise reduction on message thread (for GUI responsiveness)
                juce::MessageManager::callAsync ([this, reductionDB, profileStart, profileLength]()
                {
                    applyNoiseReductionWithSettings (reductionDB, profileStart, profileLength);
                });
            }
            delete dialog;
        }
    ), true);
}

void StandaloneWindow::applyNoiseReductionWithSettings (float reductionDB, float profileStartSec, float profileLengthSec)
{
    mainComponent->getCorrectionListView().setStatusText ("Applying noise reduction...");

    // Configure noise reduction processor
    juce::dsp::ProcessSpec spec;
    spec.sampleRate = sampleRate;
    spec.numChannels = static_cast<juce::uint32> (audioBuffer.getNumChannels());
    spec.maximumBlockSize = 2048;

    noiseReductionProcessor.prepare (spec);
    noiseReductionProcessor.setReduction (reductionDB);

    // Calculate profile sample range
    int profileStartSample = static_cast<int> (profileStartSec * sampleRate);
    int profileLengthSamples = static_cast<int> (profileLengthSec * sampleRate);
    profileStartSample = juce::jlimit (0, audioBuffer.getNumSamples() - 1, profileStartSample);
    profileLengthSamples = juce::jmin (profileLengthSamples, audioBuffer.getNumSamples() - profileStartSample);

    // Capture noise profile from specified section
    noiseReductionProcessor.captureProfile();

    // Feed profile section to the processor
    const int blockSize = 2048;
    for (int startSample = profileStartSample;
         startSample < profileStartSample + profileLengthSamples;
         startSample += blockSize)
    {
        int samplesThisBlock = juce::jmin (blockSize, profileStartSample + profileLengthSamples - startSample);

        juce::dsp::AudioBlock<float> block (audioBuffer.getArrayOfWritePointers(),
                                            static_cast<size_t> (audioBuffer.getNumChannels()),
                                            static_cast<size_t> (startSample),
                                            static_cast<size_t> (samplesThisBlock));

        juce::dsp::ProcessContextReplacing<float> context (block);
        noiseReductionProcessor.process (context);

        if (noiseReductionProcessor.hasProfile())
            break;  // Profile captured
    }

    if (!noiseReductionProcessor.hasProfile())
    {
        mainComponent->getCorrectionListView().setStatusText ("Failed to capture noise profile");
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Noise Reduction Failed",
                                                "Could not capture noise profile. Try a different section.");
        return;
    }

    // Now process the entire audio buffer
    mainComponent->getCorrectionListView().setStatusText ("Processing audio...");

    for (int startSample = 0; startSample < audioBuffer.getNumSamples(); startSample += blockSize)
    {
        int samplesThisBlock = juce::jmin (blockSize, audioBuffer.getNumSamples() - startSample);

        juce::dsp::AudioBlock<float> block (audioBuffer.getArrayOfWritePointers(),
                                            static_cast<size_t> (audioBuffer.getNumChannels()),
                                            static_cast<size_t> (startSample),
                                            static_cast<size_t> (samplesThisBlock));

        juce::dsp::ProcessContextReplacing<float> context (block);
        noiseReductionProcessor.process (context);
    }

    // Update waveform display
    mainComponent->getWaveformDisplay().updateFromBuffer (audioBuffer, sampleRate);

    hasUnsavedChanges = true;
    updateTitle();

    juce::String message = "Applied " + juce::String (reductionDB, 1) + " dB noise reduction.";
    mainComponent->getCorrectionListView().setStatusText (message);

    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Noise Reduction Complete",
                                            message);
}

void StandaloneWindow::detectTracks()
{
    if (audioBuffer.getNumSamples() == 0)
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "No Audio",
                                                "Please load an audio file first.");
        return;
    }

    TrackDetector detector;
    TrackDetector::DetectionSettings settings;
    settings.silenceThresholdDb = -40.0f;
    settings.minSilenceDurationSeconds = 2.0;
    settings.minTrackDurationSeconds = 10.0;

    auto boundaries = detector.detectTracks (audioBuffer, sampleRate, settings);

    juce::String message = "Detected " + juce::String (boundaries.size()) + " track boundaries.";
    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Track Detection",
                                            message);
}

void StandaloneWindow::splitTracks()
{
    // TODO: Implement track splitting with dialog
    juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::InfoIcon,
                                            "Split Tracks",
                                            "Track splitting will be implemented here.");
}

void StandaloneWindow::showBatchProcessor()
{
    // Create batch processor settings dialog
    auto* dialog = new juce::AlertWindow ("Batch Processor",
                                          "Configure batch processing settings:",
                                          juce::AlertWindow::QuestionIcon);

    dialog->addTextBlock ("Select files to process and configure settings:");

    // Settings
    dialog->addComboBox ("clickRemoval", {"Disabled", "Low (25)", "Medium (50)", "High (75)", "Maximum (100)"}, "Click Removal:");
    dialog->getComboBoxComponent ("clickRemoval")->setSelectedItemIndex (2); // Default: Medium

    dialog->addComboBox ("noiseReduction", {"Disabled", "6 dB", "12 dB", "18 dB", "24 dB"}, "Noise Reduction:");
    dialog->getComboBoxComponent ("noiseReduction")->setSelectedItemIndex (0); // Default: Disabled

    dialog->addComboBox ("rumbleFilter", {"Disabled", "20 Hz", "40 Hz", "60 Hz", "80 Hz"}, "Rumble Filter:");
    dialog->getComboBoxComponent ("rumbleFilter")->setSelectedItemIndex (0); // Default: Disabled

    dialog->addComboBox ("humFilter", {"Disabled", "50 Hz (EU)", "60 Hz (US)"}, "Hum Filter:");
    dialog->getComboBoxComponent ("humFilter")->setSelectedItemIndex (0); // Default: Disabled

    dialog->addComboBox ("normalize", {"Disabled", "-0.5 dB", "-1 dB", "-3 dB"}, "Normalize:");
    dialog->getComboBoxComponent ("normalize")->setSelectedItemIndex (1); // Default: -0.5 dB

    dialog->addComboBox ("bitDepth", {"16-bit", "24-bit", "32-bit float"}, "Output Bit Depth:");
    dialog->getComboBoxComponent ("bitDepth")->setSelectedItemIndex (1); // Default: 24-bit

    dialog->addButton ("Select Files...", 1);
    dialog->addButton ("Cancel", 0);

    dialog->enterModalState (true, juce::ModalCallbackFunction::create (
        [this, dialog] (int result)
        {
            if (result == 1)
            {
                // Get settings from dialog
                BatchProcessor::Settings settings;

                int clickIdx = dialog->getComboBoxComponent ("clickRemoval")->getSelectedItemIndex();
                settings.clickRemoval = clickIdx > 0;
                settings.clickSensitivity = clickIdx > 0 ? (clickIdx * 25.0f) : 0.0f;

                int noiseIdx = dialog->getComboBoxComponent ("noiseReduction")->getSelectedItemIndex();
                settings.noiseReduction = noiseIdx > 0;
                settings.noiseReductionDB = noiseIdx > 0 ? (noiseIdx * 6.0f) : 0.0f;

                int rumbleIdx = dialog->getComboBoxComponent ("rumbleFilter")->getSelectedItemIndex();
                settings.rumbleFilter = rumbleIdx > 0;
                settings.rumbleFreq = rumbleIdx > 0 ? (rumbleIdx * 20.0f) : 20.0f;

                int humIdx = dialog->getComboBoxComponent ("humFilter")->getSelectedItemIndex();
                settings.humFilter = humIdx > 0;
                settings.humFreq = humIdx == 1 ? 50.0f : 60.0f;

                int normIdx = dialog->getComboBoxComponent ("normalize")->getSelectedItemIndex();
                settings.normalize = normIdx > 0;
                float normValues[] = {0.0f, -0.5f, -1.0f, -3.0f};
                settings.normalizeDB = normValues[normIdx];

                int bitIdx = dialog->getComboBoxComponent ("bitDepth")->getSelectedItemIndex();
                int bitDepths[] = {16, 24, 32};
                settings.outputBitDepth = bitDepths[bitIdx];

                // Show file chooser
                auto chooser = std::make_shared<juce::FileChooser> ("Select Audio Files to Process",
                               juce::File::getSpecialLocation (juce::File::userHomeDirectory),
                               "*.wav;*.flac;*.aiff;*.ogg;*.mp3");

                chooser->launchAsync (juce::FileBrowserComponent::openMode |
                                     juce::FileBrowserComponent::canSelectFiles |
                                     juce::FileBrowserComponent::canSelectMultipleItems,
                    [this, settings, chooser] (const juce::FileChooser&)
                    {
                        auto results = chooser->getResults();
                        if (results.size() > 0)
                        {
                            startBatchProcessing (results, settings);
                        }
                    });
            }
            delete dialog;
        }
    ), true);
}

void StandaloneWindow::startBatchProcessing (const juce::Array<juce::File>& files, const BatchProcessor::Settings& settings)
{
    // Create batch processor
    auto batchProcessor = std::make_unique<BatchProcessor>();

    // Add files to queue
    for (const auto& file : files)
    {
        batchProcessor->addFile (file);
    }

    // Set progress callback
    batchProcessor->setProgressCallback ([this] (const BatchProcessor::ProgressInfo& info)
    {
        mainComponent->getCorrectionListView().setStatusText (
            "Batch: " + juce::String (info.currentFileIndex) + "/" +
            juce::String (info.totalFiles) + " - " + info.currentFileName);
    });

    // Set completion callback
    batchProcessor->setCompletionCallback ([this] (bool success, const juce::String& message)
    {
        mainComponent->getCorrectionListView().setStatusText ("Ready");
        juce::AlertWindow::showMessageBoxAsync (
            success ? juce::AlertWindow::InfoIcon : juce::AlertWindow::WarningIcon,
            "Batch Processing Complete",
            message);
    });

    // Start processing
    mainComponent->getCorrectionListView().setStatusText ("Starting batch processing...");
    batchProcessor->startProcessing (settings);

    // Note: batchProcessor will be destroyed here, but the thread will continue
    // This is a limitation - in production, we'd want to keep the processor alive
    // For now, we'll just start it and let it run
    batchProcessor.release();  // Release ownership to prevent deletion
}

void StandaloneWindow::showAboutDialog()
{
    // Borderless about overlay that closes on any click
    class AboutOverlay : public juce::Component
    {
    public:
        AboutOverlay()
        {
            setOpaque (false);
            setWantsKeyboardFocus (true);
        }

        void paint (juce::Graphics& g) override
        {
            auto bounds = getLocalBounds().toFloat();

            // Semi-transparent dark overlay for entire screen
            g.fillAll (juce::Colour (0xcc000000));

            // Calculate centered content area (twice the original size: 1000x1160)
            float contentWidth = 1000.0f;
            float contentHeight = 1100.0f;
            float contentX = (bounds.getWidth() - contentWidth) / 2.0f;
            float contentY = (bounds.getHeight() - contentHeight) / 2.0f;

            // Draw rounded content background
            juce::Rectangle<float> contentBounds (contentX, contentY, contentWidth, contentHeight);
            g.setColour (juce::Colour (0xff1a1a1a));
            g.fillRoundedRectangle (contentBounds, 20.0f);

            // Subtle border
            g.setColour (juce::Colour (0xff3a3a3a));
            g.drawRoundedRectangle (contentBounds, 20.0f, 2.0f);

            // Vinyl record area - twice as big (760px instead of 380px)
            float vinylSize = 760.0f;
            float vinylX = contentX + (contentWidth - vinylSize) / 2.0f;
            float vinylY = contentY + 40.0f;
            auto centre = juce::Point<float> (vinylX + vinylSize / 2.0f, vinylY + vinylSize / 2.0f);
            float radius = vinylSize / 2.0f;

            // Draw outer shadow/glow
            for (int i = 25; i > 0; --i)
            {
                float alpha = 0.015f * (25 - i);
                g.setColour (juce::Colours::black.withAlpha (alpha));
                g.fillEllipse (centre.x - radius - i, centre.y - radius - i,
                              (radius + i) * 2.0f, (radius + i) * 2.0f);
            }

            // Draw vinyl record (black disc)
            g.setColour (juce::Colour (0xff0a0a0a));
            g.fillEllipse (centre.x - radius, centre.y - radius, radius * 2.0f, radius * 2.0f);

            // Draw grooves (concentric circles) - more of them for larger vinyl
            g.setColour (juce::Colour (0xff1a1a1a));
            for (float r = radius * 0.50f; r < radius * 0.98f; r += 3.0f)
            {
                g.drawEllipse (centre.x - r, centre.y - r, r * 2.0f, r * 2.0f, 0.6f);
            }

            // Draw shiny reflection on vinyl
            g.setColour (juce::Colours::white.withAlpha (0.05f));
            g.fillEllipse (centre.x - radius * 0.7f, centre.y - radius * 0.85f,
                          radius * 0.9f, radius * 0.5f);

            // Draw label area (center circle) with gold gradient
            float labelRadius = radius * 0.48f;
            juce::ColourGradient gradient (juce::Colour (0xffe8c547), centre.x - labelRadius * 0.3f, centre.y - labelRadius * 0.3f,
                                          juce::Colour (0xffc9a227), centre.x + labelRadius * 0.5f, centre.y + labelRadius * 0.5f,
                                          true);
            g.setGradientFill (gradient);
            g.fillEllipse (centre.x - labelRadius, centre.y - labelRadius,
                          labelRadius * 2.0f, labelRadius * 2.0f);

            // Draw label border (dark ring)
            g.setColour (juce::Colour (0xff8b7355));
            g.drawEllipse (centre.x - labelRadius, centre.y - labelRadius,
                          labelRadius * 2.0f, labelRadius * 2.0f, 5.0f);

            // Draw spindle hole (center)
            float holeRadius = radius * 0.045f;
            g.setColour (juce::Colour (0xff2a2a2a));
            g.fillEllipse (centre.x - holeRadius, centre.y - holeRadius,
                          holeRadius * 2.0f, holeRadius * 2.0f);

            // Draw text on label - MUCH LARGER FONTS for 2x size
            // Layout: Name ABOVE spindle, company/year BELOW spindle, version at bottom
            g.setColour (juce::Colour (0xff2a2008));

            // Title ABOVE the spindle - big and bold
            g.setFont (juce::Font (juce::FontOptions (44.0f)).boldened());
            g.drawText ("Vinyl Restoration",
                       centre.x - labelRadius * 0.9f, centre.y - labelRadius * 0.78f,
                       labelRadius * 1.8f, 52.0f,
                       juce::Justification::centred);

            g.setFont (juce::Font (juce::FontOptions (40.0f)).boldened());
            g.drawText ("Suite",
                       centre.x - labelRadius * 0.9f, centre.y - labelRadius * 0.48f,
                       labelRadius * 1.8f, 48.0f,
                       juce::Justification::centred);

            // Divider line above spindle
            g.setColour (juce::Colour (0xff5a4a28));
            g.drawHorizontalLine ((int) (centre.y - labelRadius * 0.18f),
                                  centre.x - labelRadius * 0.5f,
                                  centre.x + labelRadius * 0.5f);

            // ===== SPINDLE HOLE IS AT centre.y =====

            // Divider line below spindle
            g.drawHorizontalLine ((int) (centre.y + labelRadius * 0.18f),
                                  centre.x - labelRadius * 0.5f,
                                  centre.x + labelRadius * 0.5f);

            // Company name BELOW the spindle
            g.setColour (juce::Colour (0xff2a2008));
            g.setFont (juce::Font (juce::FontOptions (26.0f)).boldened());
            g.drawText ("flarkAUDIO",
                       centre.x - labelRadius * 0.9f, centre.y + labelRadius * 0.25f,
                       labelRadius * 1.8f, 36.0f,
                       juce::Justification::centred);

            // Year
            g.setFont (juce::Font (juce::FontOptions (22.0f)));
            g.drawText ("2024-2025",
                       centre.x - labelRadius * 0.9f, centre.y + labelRadius * 0.45f,
                       labelRadius * 1.8f, 32.0f,
                       juce::Justification::centred);

            // Version at bottom of label
            g.setFont (juce::Font (juce::FontOptions (20.0f)));
            g.drawText ("Version 1.5.2",
                       centre.x - labelRadius * 0.9f, centre.y + labelRadius * 0.68f,
                       labelRadius * 1.8f, 28.0f,
                       juce::Justification::centred);

            // Features text below vinyl - larger fonts
            g.setColour (juce::Colours::lightgrey);
            g.setFont (juce::Font (juce::FontOptions (22.0f)));

            float textY = vinylY + vinylSize + 40.0f;
            g.drawText ("Professional audio restoration for vinyl and tape transfers",
                       contentX + 40.0f, textY, contentWidth - 80.0f, 32.0f,
                       juce::Justification::centred);

            g.setColour (juce::Colours::grey);
            g.setFont (juce::Font (juce::FontOptions (20.0f)));
            g.drawText ("Click removal  -  Noise reduction  -  Graphic EQ  -  Track detection",
                       contentX + 40.0f, textY + 40.0f, contentWidth - 80.0f, 28.0f,
                       juce::Justification::centred);

            // Close hint at bottom
            g.setColour (juce::Colours::darkgrey);
            g.setFont (juce::Font (juce::FontOptions (18.0f)));
            g.drawText ("Click anywhere to close",
                       contentX + 40.0f, contentY + contentHeight - 50.0f, contentWidth - 80.0f, 28.0f,
                       juce::Justification::centred);
        }

        void mouseDown (const juce::MouseEvent&) override
        {
            // Close on any click
            delete this;
        }

        bool keyPressed (const juce::KeyPress& key) override
        {
            // Close on Escape
            if (key == juce::KeyPress::escapeKey)
            {
                delete this;
                return true;
            }
            return false;
        }

        void inputAttemptWhenModal() override
        {
            // Close when clicking outside (modal input attempt)
            delete this;
        }
    };

    // Create and show the overlay
    auto* overlay = new AboutOverlay();

    // Get the display bounds to cover the entire screen area
    auto displayBounds = juce::Desktop::getInstance().getDisplays().getPrimaryDisplay()->userArea;
    overlay->setBounds (displayBounds);

    // Add to desktop as a borderless window
    overlay->addToDesktop (juce::ComponentPeer::windowIsTemporary);
    overlay->setVisible (true);
    overlay->toFront (true);
    overlay->grabKeyboardFocus();

    // Enter modal state so it captures all input
    overlay->enterModalState (true, nullptr, true);
}

void StandaloneWindow::updateTitle()
{
    juce::String title = "Vinyl Restoration Suite";

    if (currentFile.exists())
    {
        title += " - " + currentFile.getFileName();
        if (hasUnsavedChanges)
            title += " *";
    }

    setName (title);

    // Also update the native title bar
    if (getPeer() != nullptr)
        getPeer()->setTitle (title);
}

void StandaloneWindow::loadSession (const juce::File& sessionFile)
{
    juce::File audioFile;
    juce::var sessionData;

    if (!fileManager.loadSession (sessionFile, audioFile, sessionData))
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Load Session Failed",
                                                "Could not load session file.\nThe audio file may have been moved or deleted.");
        return;
    }

    // Load the referenced audio file
    if (!fileManager.loadAudioFile (audioFile, audioBuffer, sampleRate))
    {
        juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon,
                                                "Load Session Failed",
                                                "Could not load the audio file referenced by this session.");
        return;
    }

    currentFile = audioFile;
    recentFiles.addFile (sessionFile);

    // Update waveform display
    mainComponent->getWaveformDisplay().loadFile (audioFile);
    mainComponent->setAudioBuffer (&audioBuffer, sampleRate);

    // Load into transport source for playback
    juce::AudioFormatManager formatManager;
    formatManager.registerBasicFormats();
    formatManager.registerFormat (new juce::FlacAudioFormat(), true);
    formatManager.registerFormat (new juce::OggVorbisAudioFormat(), true);

    #if JUCE_USE_MP3AUDIOFORMAT
    formatManager.registerFormat (new juce::MP3AudioFormat(), true);
    #endif

    auto* reader = formatManager.createReaderFor (audioFile);
    if (reader != nullptr)
    {
        readerSource.reset (new juce::AudioFormatReaderSource (reader, true));
        transportSource.setSource (readerSource.get(), 0, nullptr, reader->sampleRate);
    }

    // TODO: Restore corrections from sessionData
    mainComponent->getCorrectionListView().clearCorrections();

    hasUnsavedChanges = false;
    updateTitle();

    DBG ("Session loaded: " + sessionFile.getFullPathName());
    DBG ("Audio file: " + audioFile.getFullPathName());

    auto durationSec = audioBuffer.getNumSamples() / sampleRate;
    juce::String status = "Session loaded: " + juce::String (durationSec / 60.0, 1) + " min";
    mainComponent->getCorrectionListView().setStatusText (status);
}

void StandaloneWindow::showAudioSettings()
{
    // Show JUCE's built-in audio settings dialog
    juce::DialogWindow::LaunchOptions options;
    options.dialogTitle = "Audio Settings";
    options.dialogBackgroundColour = juce::Colours::darkgrey;
    options.content.setOwned (new juce::AudioDeviceSelectorComponent (
        audioDeviceManager,
        0,  // min input channels
        0,  // max input channels
        2,  // min output channels
        2,  // max output channels
        false,  // show MIDI input
        false,  // show MIDI output
        false,  // show channels as stereo pairs
        false   // hide advanced options
    ));
    options.content->setSize (500, 400);
    options.launchAsync();
}

void StandaloneWindow::setUIScale (float newScale)
{
    if (std::abs (newScale - uiScaleFactor) < 0.01f)
        return;

    uiScaleFactor = juce::jlimit (0.25f, 4.0f, newScale);

    // Calculate new window size
    int scaledWidth = juce::roundToInt (baseWidth * uiScaleFactor);
    int scaledHeight = juce::roundToInt (baseHeight * uiScaleFactor);

    // Apply scale via the wrapper
    if (contentWrapper != nullptr)
    {
        contentWrapper->setScaleFactor (uiScaleFactor);
        contentWrapper->setSize (scaledWidth, scaledHeight);
    }

    // Update window constraints based on scale
    setResizeLimits (
        juce::roundToInt (600 * uiScaleFactor),
        juce::roundToInt (400 * uiScaleFactor),
        juce::roundToInt (3840 * uiScaleFactor),
        juce::roundToInt (2160 * uiScaleFactor));

    // Resize the window to fit the scaled content
    setSize (scaledWidth, scaledHeight);

    DBG ("UI Scale set to: " + juce::String (uiScaleFactor * 100.0f, 0) + "%");
}

//==============================================================================
// MainComponent Implementation
//==============================================================================

StandaloneWindow::MainComponent::MainComponent()
{
    // Load logo from embedded PNG data
    #include "../Resources/VRSLogoData.h"
    logoImage = juce::ImageFileFormat::loadFrom (VRSlogo_png, VRSlogo_png_len);

    // Add waveform display
    addAndMakeVisible (waveformDisplay);

    // Add correction list
    addAndMakeVisible (correctionListView);

    // Transport controls (retro cassette deck style)
    addAndMakeVisible (rewindButton);
    addAndMakeVisible (playPauseButton);
    addAndMakeVisible (stopButton);
    addAndMakeVisible (forwardButton);

    rewindButton.addListener (this);
    playPauseButton.addListener (this);
    stopButton.addListener (this);
    forwardButton.addListener (this);

    rewindButton.setTooltip ("Skip backward 5 seconds");
    playPauseButton.setTooltip ("Play/Pause playback (Spacebar)");
    stopButton.setTooltip ("Stop playback and return to start");
    forwardButton.setTooltip ("Skip forward 5 seconds");

    // Enable keyboard focus for spacebar control
    setWantsKeyboardFocus (true);

    // Position slider
    addAndMakeVisible (positionSlider);
    positionSlider.setRange (0.0, 1.0);
    positionSlider.setTextBoxStyle (juce::Slider::NoTextBox, false, 0, 0);
    positionSlider.addListener (this);
    positionSlider.setTooltip ("Seek playback position");

    // Time label
    addAndMakeVisible (timeLabel);
    timeLabel.setText ("00:00.000", juce::dontSendNotification);
    timeLabel.setJustificationType (juce::Justification::centred);

    // Volume slider
    addAndMakeVisible (volumeSlider);
    volumeSlider.setRange (0.0, 100.0, 1.0);  // 0-100% with 1% steps
    volumeSlider.setValue (70.0); // 70% default volume
    volumeSlider.setSliderStyle (juce::Slider::LinearVertical);
    volumeSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, 50, 20);
    volumeSlider.setTextValueSuffix ("%");
    volumeSlider.addListener (this);
    volumeSlider.setTooltip ("Adjust playback volume (0-100%)");

    // Volume label
    addAndMakeVisible (volumeLabel);
    volumeLabel.setText ("Volume", juce::dontSendNotification);
    volumeLabel.setJustificationType (juce::Justification::centred);

    // Zoom controls
    addAndMakeVisible (zoomInButton);
    addAndMakeVisible (zoomOutButton);
    addAndMakeVisible (zoomFitButton);

    zoomInButton.addListener (this);
    zoomOutButton.addListener (this);
    zoomFitButton.addListener (this);

    zoomInButton.setTooltip ("Zoom in waveform horizontally");
    zoomOutButton.setTooltip ("Zoom out waveform horizontally");
    zoomFitButton.setTooltip ("Fit entire waveform in view");

    // Horizontal zoom slider (below waveform)
    addAndMakeVisible (horizontalZoomSlider);
    horizontalZoomSlider.setRange (1.0, 100.0, 0.1);
    horizontalZoomSlider.setValue (1.0);
    horizontalZoomSlider.setSkewFactorFromMidPoint (10.0);
    horizontalZoomSlider.setSliderStyle (juce::Slider::LinearHorizontal);
    horizontalZoomSlider.setTextBoxStyle (juce::Slider::TextBoxRight, false, 60, 20);
    horizontalZoomSlider.addListener (this);
    horizontalZoomSlider.setTooltip ("Horizontal zoom (1x to 100x)");

    addAndMakeVisible (horizontalZoomLabel);
    horizontalZoomLabel.setText ("H-Zoom:", juce::dontSendNotification);
    horizontalZoomLabel.setJustificationType (juce::Justification::centredRight);

    // Vertical zoom slider (next to waveform)
    addAndMakeVisible (verticalZoomSlider);
    verticalZoomSlider.setRange (0.1, 10.0, 0.1);
    verticalZoomSlider.setValue (1.0);
    verticalZoomSlider.setSkewFactorFromMidPoint (1.0);
    verticalZoomSlider.setSliderStyle (juce::Slider::LinearVertical);
    verticalZoomSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, 50, 20);
    verticalZoomSlider.addListener (this);
    verticalZoomSlider.setTooltip ("Vertical zoom (amplitude)");

    addAndMakeVisible (verticalZoomLabel);
    verticalZoomLabel.setText ("V-Zoom", juce::dontSendNotification);
    verticalZoomLabel.setJustificationType (juce::Justification::centred);

    // Selection editor
    addAndMakeVisible (selectionStartLabel);
    selectionStartLabel.setText ("Start:", juce::dontSendNotification);
    selectionStartLabel.setJustificationType (juce::Justification::centredRight);

    addAndMakeVisible (selectionStartEditor);
    selectionStartEditor.setInputRestrictions (12, "0123456789.:,");
    selectionStartEditor.setTooltip ("Selection start time (mm:ss.ms)");

    addAndMakeVisible (selectionEndLabel);
    selectionEndLabel.setText ("End:", juce::dontSendNotification);
    selectionEndLabel.setJustificationType (juce::Justification::centredRight);

    addAndMakeVisible (selectionEndEditor);
    selectionEndEditor.setInputRestrictions (12, "0123456789.:,");
    selectionEndEditor.setTooltip ("Selection end time (mm:ss.ms)");

    addAndMakeVisible (selectionLengthLabel);
    selectionLengthLabel.setText ("Length: 00:00.000", juce::dontSendNotification);
    selectionLengthLabel.setJustificationType (juce::Justification::centredLeft);

    addAndMakeVisible (clearSelectionButton);
    clearSelectionButton.addListener (this);
    clearSelectionButton.setTooltip ("Clear current selection");

    // Enable keyboard focus for spacebar handling
    setWantsKeyboardFocus (true);

    // Status label
    addAndMakeVisible (statusLabel);
    statusLabel.setText ("Ready", juce::dontSendNotification);
    statusLabel.setJustificationType (juce::Justification::centredLeft);

    // Create resizer divider for waveform/correction list split
    addAndMakeVisible (resizeDivider);
    resizeDivider.onDrag = [this] (int deltaY)
    {
        // Update waveform height based on drag
        int newHeight = waveformHeight + deltaY;
        newHeight = juce::jlimit (100, getHeight() - 200, newHeight);  // Min 100px, leave space for other controls
        if (newHeight != waveformHeight)
        {
            waveformHeight = newHeight;
            resized();
        }
    };

    // Setup waveform display callbacks
    waveformDisplay.onSelectionChanged = [this] (int64_t start, int64_t end)
    {
        // Update selection editor with start/end/length values
        if (currentBuffer != nullptr && currentSampleRate > 0)
        {
            double startSeconds = start / currentSampleRate;
            double endSeconds = end / currentSampleRate;
            double lengthSeconds = (end - start) / currentSampleRate;

            int startMinutes = (int) (startSeconds / 60.0);
            double startSecs = startSeconds - startMinutes * 60;
            int endMinutes = (int) (endSeconds / 60.0);
            double endSecs = endSeconds - endMinutes * 60;
            int lengthMinutes = (int) (lengthSeconds / 60.0);
            double lengthSecs = lengthSeconds - lengthMinutes * 60;

            selectionStartEditor.setText (juce::String::formatted ("%02d:%06.3f", startMinutes, startSecs), juce::dontSendNotification);
            selectionEndEditor.setText (juce::String::formatted ("%02d:%06.3f", endMinutes, endSecs), juce::dontSendNotification);
            selectionLengthLabel.setText ("Length: " + juce::String::formatted ("%02d:%06.3f", lengthMinutes, lengthSecs), juce::dontSendNotification);

            // Set playback position to selection start so next play starts from selection
            if (parentWindow && !parentWindow->isPlaying)
            {
                parentWindow->transportSource.setPosition (startSeconds);
                double totalLength = currentBuffer->getNumSamples() / currentSampleRate;
                if (totalLength > 0)
                {
                    double position = startSeconds / totalLength;
                    positionSlider.setValue (position, juce::dontSendNotification);
                    waveformDisplay.setPlaybackPosition (position);
                }
            }
        }
    };
}

StandaloneWindow::MainComponent::~MainComponent()
{
}

void StandaloneWindow::MainComponent::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colour (0xff2e2e2e));

    // Draw logo in the top right corner (in the volume slider area)
    if (logoImage.isValid())
    {
        int logoWidth = 60;
        int logoHeight = (int) (logoImage.getHeight() * (logoWidth / (float) logoImage.getWidth()));
        int x = getWidth() - logoWidth - 10;  // Top right corner
        int y = 55;  // Below transport controls

        g.setOpacity (0.9f);
        g.drawImage (logoImage, x, y, logoWidth, logoHeight,
                     0, 0, logoImage.getWidth(), logoImage.getHeight());
        g.setOpacity (1.0f);
    }
}

void StandaloneWindow::MainComponent::resized()
{
    auto area = getLocalBounds();

    // Menu bar at very top (if present)
    for (auto* child : getChildren())
    {
        if (auto* menuBar = dynamic_cast<juce::MenuBarComponent*> (child))
        {
            menuBar->setBounds (area.removeFromTop (juce::LookAndFeel::getDefaultLookAndFeel()
                                                    .getDefaultMenuBarHeight()));
            break;
        }
    }

    // Volume slider uses right side of window (80px wide), but leave room for logo at top
    auto volumeArea = area.removeFromRight (80);
    volumeArea.reduce (10, 10);

    // Leave space at top for the logo (logo is ~60px wide, ~100px tall with padding)
    volumeArea.removeFromTop (120);  // Space for logo above volume slider

    // Reserve space at very bottom for volume label (under slider's text box)
    auto volumeLabelArea = volumeArea.removeFromBottom (20);
    volumeLabel.setBounds (volumeLabelArea);

    // The slider has TextBoxBelow which adds ~20px, so leave some margin
    volumeArea.removeFromBottom (25);  // Space for slider's built-in text box

    // Volume slider fills remaining vertical space (shorter now)
    volumeSlider.setBounds (volumeArea);

    // Left side contains all other content
    area.removeFromRight (5); // spacing

    // Transport controls at top (cassette deck style)
    auto transportArea = area.removeFromTop (50);
    transportArea.reduce (10, 10);

    rewindButton.setBounds (transportArea.removeFromLeft (50));
    transportArea.removeFromLeft (5);
    playPauseButton.setBounds (transportArea.removeFromLeft (80));  // Wider for toggle button
    transportArea.removeFromLeft (5);
    stopButton.setBounds (transportArea.removeFromLeft (60));
    transportArea.removeFromLeft (5);
    forwardButton.setBounds (transportArea.removeFromLeft (50));
    transportArea.removeFromLeft (10);

    // Time label and position slider
    timeLabel.setBounds (transportArea.removeFromRight (100));
    transportArea.removeFromRight (10);
    positionSlider.setBounds (transportArea);

    // Constants for control heights
    const int resizerHeight = 10;

    // Waveform area - use stored height
    auto waveformArea = area.removeFromTop (waveformHeight);

    // Vertical zoom slider on left side of waveform
    auto vZoomArea = waveformArea.removeFromLeft (50);
    vZoomArea.reduce (5, 10);

    verticalZoomLabel.setBounds (vZoomArea.removeFromTop (50));
    verticalZoomSlider.setBounds (vZoomArea);

    waveformArea.removeFromLeft (5); // Small gap
    waveformDisplay.setBounds (waveformArea);

    // Resizer divider between waveform and controls
    resizeDivider.setBounds (area.removeFromTop (resizerHeight));

    // Zoom buttons + horizontal zoom slider directly under resizer (same row)
    auto zoomButtonArea = area.removeFromTop (40);
    zoomButtonArea.reduce (10, 5);

    zoomInButton.setBounds (zoomButtonArea.removeFromLeft (40));
    zoomButtonArea.removeFromLeft (5);
    zoomOutButton.setBounds (zoomButtonArea.removeFromLeft (40));
    zoomButtonArea.removeFromLeft (5);
    zoomFitButton.setBounds (zoomButtonArea.removeFromLeft (60));
    zoomButtonArea.removeFromLeft (10);

    // Horizontal zoom slider on same row as buttons
    horizontalZoomLabel.setBounds (zoomButtonArea.removeFromLeft (60));
    zoomButtonArea.removeFromLeft (5);
    horizontalZoomSlider.setBounds (zoomButtonArea);

    area.removeFromTop (5); // Small gap

    // Selection editor directly under zoom buttons
    auto selectionArea = area.removeFromTop (35);
    selectionArea.reduce (10, 5);

    selectionStartLabel.setBounds (selectionArea.removeFromLeft (45));
    selectionArea.removeFromLeft (3);
    selectionStartEditor.setBounds (selectionArea.removeFromLeft (85));
    selectionArea.removeFromLeft (10);

    selectionEndLabel.setBounds (selectionArea.removeFromLeft (35));
    selectionArea.removeFromLeft (3);
    selectionEndEditor.setBounds (selectionArea.removeFromLeft (85));
    selectionArea.removeFromLeft (10);

    selectionLengthLabel.setBounds (selectionArea.removeFromLeft (150));
    selectionArea.removeFromLeft (10);

    clearSelectionButton.setBounds (selectionArea.removeFromLeft (60));

    area.removeFromTop (5); // Small gap

    // Status bar at bottom
    auto statusArea = area.removeFromBottom (30);
    statusArea.reduce (10, 5);
    statusLabel.setBounds (statusArea);

    // Correction list takes remaining space
    correctionListView.setBounds (area);
}

void StandaloneWindow::MainComponent::buttonClicked (juce::Button* button)
{
    if (button == &playPauseButton)
    {
        if (parentWindow && parentWindow->transportSource.getTotalLength() > 0.0)
        {
            if (parentWindow->isPlaying)
            {
                // Pause
                parentWindow->transportSource.stop();
                parentWindow->isPlaying = false;
                playPauseButton.setButtonText ("Play");
                DBG ("Playback paused");
            }
            else
            {
                // Play/Resume
                parentWindow->transportSource.start();
                parentWindow->isPlaying = true;
                playPauseButton.setButtonText ("Pause");
                DBG ("Playback started");
            }
        }
    }
    else if (button == &stopButton)
    {
        if (parentWindow)
        {
            parentWindow->transportSource.stop();
            parentWindow->transportSource.setPosition (0.0);
            parentWindow->isPlaying = false;
            playPauseButton.setButtonText ("Play");
            DBG ("Playback stopped");
        }
    }
    else if (button == &rewindButton)
    {
        // Skip backward 5 seconds
        if (parentWindow && parentWindow->transportSource.getTotalLength() > 0.0)
        {
            double currentPos = parentWindow->transportSource.getCurrentPosition();
            double newPos = juce::jmax (0.0, currentPos - 5.0);
            parentWindow->transportSource.setPosition (newPos);
            DBG ("Rewound to: " + juce::String (newPos, 2) + "s");
        }
    }
    else if (button == &forwardButton)
    {
        // Skip forward 5 seconds
        if (parentWindow && parentWindow->transportSource.getTotalLength() > 0.0)
        {
            double currentPos = parentWindow->transportSource.getCurrentPosition();
            double totalLength = parentWindow->transportSource.getLengthInSeconds();
            double newPos = juce::jmin (totalLength, currentPos + 5.0);
            parentWindow->transportSource.setPosition (newPos);
            DBG ("Fast-forwarded to: " + juce::String (newPos, 2) + "s");
        }
    }
    else if (button == &zoomInButton)
    {
        // Zoom in = increase zoom multiplier
        double newZoom = waveformDisplay.horizontalZoom * 2.0;
        waveformDisplay.setHorizontalZoom (newZoom);
        horizontalZoomSlider.setValue (newZoom, juce::dontSendNotification);
    }
    else if (button == &zoomOutButton)
    {
        // Zoom out = decrease zoom multiplier
        double newZoom = juce::jmax (1.0, waveformDisplay.horizontalZoom * 0.5);
        waveformDisplay.setHorizontalZoom (newZoom);
        horizontalZoomSlider.setValue (newZoom, juce::dontSendNotification);
    }
    else if (button == &zoomFitButton)
    {
        // Fit entire waveform
        waveformDisplay.setHorizontalZoom (1.0);
        waveformDisplay.scrollPosition = 0.0;
        horizontalZoomSlider.setValue (1.0, juce::dontSendNotification);
    }
    else if (button == &clearSelectionButton)
    {
        // Clear waveform selection
        waveformDisplay.clearSelection();

        selectionStartEditor.setText ("");
        selectionEndEditor.setText ("");
        selectionLengthLabel.setText ("Length: 00:00.000", juce::dontSendNotification);

        DBG ("Selection cleared");
    }
}

void StandaloneWindow::MainComponent::sliderValueChanged (juce::Slider* slider)
{
    if (slider == &positionSlider)
    {
        double position = positionSlider.getValue();
        waveformDisplay.setPlaybackPosition (position);

        // Instant seek: update transport source position (even during playback)
        if (parentWindow && currentBuffer != nullptr)
        {
            double timeInSeconds = position * (currentBuffer->getNumSamples() / currentSampleRate);
            parentWindow->transportSource.setPosition (timeInSeconds);

            // Update time label
            int minutes = (int) (timeInSeconds / 60.0);
            double seconds = timeInSeconds - minutes * 60;
            juce::String timeString = juce::String::formatted ("%02d:%06.3f", minutes, seconds);
            timeLabel.setText (timeString, juce::dontSendNotification);
        }
    }
    else if (slider == &volumeSlider)
    {
        // Update volume (slider is 0-100, gain is 0-1)
        float volume = (float) volumeSlider.getValue() / 100.0f;
        if (parentWindow)
        {
            parentWindow->transportSource.setGain (volume);
            DBG ("Volume set to: " + juce::String (volumeSlider.getValue(), 0) + "%");
        }
    }
    else if (slider == &horizontalZoomSlider)
    {
        // Update horizontal zoom
        double zoomValue = horizontalZoomSlider.getValue();
        waveformDisplay.setHorizontalZoom (zoomValue);
        DBG ("Horizontal zoom: " + juce::String (zoomValue, 1) + "x");
    }
    else if (slider == &verticalZoomSlider)
    {
        // Update vertical zoom
        double zoomValue = verticalZoomSlider.getValue();
        waveformDisplay.setVerticalZoom (zoomValue);
        DBG ("Vertical zoom: " + juce::String (zoomValue, 1) + "x");
    }
}

bool StandaloneWindow::MainComponent::keyPressed (const juce::KeyPress& key)
{
    // Spacebar toggles play/pause
    if (key == juce::KeyPress::spaceKey)
    {
        if (parentWindow && parentWindow->currentFile.exists())
        {
            if (parentWindow->isPlaying)
            {
                // Pause playback
                parentWindow->transportSource.stop();
                parentWindow->isPlaying = false;
                playPauseButton.setButtonText ("Play");
                DBG ("Playback paused (spacebar)");
            }
            else
            {
                // Start/resume playback
                parentWindow->transportSource.start();
                parentWindow->isPlaying = true;
                playPauseButton.setButtonText ("Pause");
                DBG ("Playback started (spacebar)");
            }
            return true; // Key was handled
        }
    }

    // Home key - go to beginning
    if (key == juce::KeyPress::homeKey)
    {
        if (parentWindow && parentWindow->currentFile.exists())
        {
            parentWindow->transportSource.setPosition (0.0);
            waveformDisplay.setPlaybackPosition (0.0);
            updatePlaybackPosition (0.0);
            DBG ("Transport: Go to beginning (Home)");
            return true;
        }
    }

    // End key - go to end
    if (key == juce::KeyPress::endKey)
    {
        if (parentWindow && parentWindow->currentFile.exists())
        {
            double length = parentWindow->transportSource.getLengthInSeconds();
            parentWindow->transportSource.setPosition (length);
            waveformDisplay.setPlaybackPosition (1.0);
            updatePlaybackPosition (1.0);
            DBG ("Transport: Go to end (End)");
            return true;
        }
    }

    return false; // Key not handled
}

void StandaloneWindow::MainComponent::mouseWheelMove (const juce::MouseEvent& event, const juce::MouseWheelDetails& wheel)
{
    // Mouse wheel scrubbing on position slider area
    if (positionSlider.getBounds().contains (event.getPosition()) && parentWindow && currentBuffer != nullptr)
    {
        double currentPos = positionSlider.getValue();
        double delta = wheel.deltaY * 0.01;  // Scroll sensitivity
        double newPos = juce::jlimit (0.0, 1.0, currentPos + delta);

        positionSlider.setValue (newPos, juce::sendNotificationSync);

        // The slider value changed handler will update the transport position
        event.source.enableUnboundedMouseMovement (false);
    }
}

void StandaloneWindow::MainComponent::setAudioBuffer (const juce::AudioBuffer<float>* buffer, double sampleRate)
{
    currentBuffer = buffer;
    currentSampleRate = sampleRate;

    if (buffer != nullptr)
    {
        statusLabel.setText (juce::String (buffer->getNumChannels()) + " channels, " +
                           juce::String (sampleRate / 1000.0, 1) + " kHz, " +
                           juce::String (buffer->getNumSamples() / sampleRate, 2) + " seconds",
                           juce::dontSendNotification);

        // Grab keyboard focus so spacebar works immediately after loading
        grabKeyboardFocus();
    }
}

void StandaloneWindow::MainComponent::updatePlaybackPosition (double position)
{
    positionSlider.setValue (position, juce::dontSendNotification);
    waveformDisplay.setPlaybackPosition (position);
}
