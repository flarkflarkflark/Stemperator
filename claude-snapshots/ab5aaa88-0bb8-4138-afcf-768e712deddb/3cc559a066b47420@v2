#include <clap/clap.h>
#include <stdlib.h>
#include <string.h>
#include "plugin.h"

// Plugin descriptor
const clap_plugin_descriptor_t s_plugin_desc = {
    .clap_version = CLAP_VERSION_INIT,
    .id = "com.flark.matrixfilter",
    .name = "flark's MatrixFilter",
    .vendor = "flark",
    .url = "https://flark.dev/matrixfilter",
    .manual_url = "https://flark.dev/matrixfilter/manual",
    .support_url = "https://flark.dev/matrixfilter/support",
    .version = "1.0.0",
    .description = "A versatile audio filter plugin supporting multiple filter types including low-pass, high-pass, band-pass, notch, peaking, and shelf filters.",
    .features = (const char *[]){
        CLAP_PLUGIN_FEATURE_AUDIO_EFFECT,
        CLAP_PLUGIN_FEATURE_FILTER,
        CLAP_PLUGIN_FEATURE_STEREO,
        NULL
    },
};

// Plugin extensions (defined in other files)
extern "C" {
extern const clap_plugin_params_t s_plugin_params;
extern const clap_plugin_state_t s_plugin_state;
extern const clap_plugin_latency_t s_plugin_latency;
extern const clap_plugin_audio_ports_t s_plugin_audio_ports;
}
// TODO: Fix these extensions to match CLAP API version
// extern const clap_plugin_ambisonic_t s_plugin_ambisonic;
// extern const clap_plugin_surround_t s_plugin_surround;
// extern const clap_plugin_gui_t s_plugin_gui;

// Function declarations
static void destroy(audio_filter_plugin_t *plugin);
static bool init(audio_filter_plugin_t *plugin);
static void deactivate(audio_filter_plugin_t *plugin);
static bool start_processing(const audio_filter_plugin_t *plugin);
static void stop_processing(const audio_filter_plugin_t *plugin);
static void reset(audio_filter_plugin_t *plugin);
static clap_process_status process(audio_filter_plugin_t *plugin, const clap_process_t *process);
static const void *get_extension(const audio_filter_plugin_t *plugin, const char *id);
static void on_main_thread(const audio_filter_plugin_t *plugin);
static bool audio_filter_activate(const clap_plugin_t *plugin, double sample_rate, uint32_t min_frames_count, uint32_t max_frames_count);

// Plugin methods
static void audio_filter_destroy(const clap_plugin_t *plugin) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    destroy(p);
}

static bool audio_filter_init(const clap_plugin_t *plugin) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    return init(p);
}

static void audio_filter_deactivate(const clap_plugin_t *plugin) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    deactivate(p);
}

static bool audio_filter_start_processing(const clap_plugin_t *plugin) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    return start_processing(p);
}

static void audio_filter_stop_processing(const clap_plugin_t *plugin) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    stop_processing(p);
}

static void audio_filter_reset(const clap_plugin_t *plugin) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    reset(p);
}

static clap_process_status audio_filter_process(const clap_plugin_t *plugin, const clap_process_t *process_data) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    return process(p, process_data);
}

static const void *audio_filter_get_extension(const clap_plugin_t *plugin, const char *id) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    return get_extension(p, id);
}

static void audio_filter_on_main_thread(const clap_plugin_t *plugin) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    on_main_thread(p);
}

// Plugin implementation
static void destroy(audio_filter_plugin_t *plugin) {
    if (plugin->temp_buffer) {
        free(plugin->temp_buffer);
        plugin->temp_buffer = NULL;
    }
    free(plugin);
}

static bool init(audio_filter_plugin_t *plugin) {
    // Initialize DSP
    filter_init(&plugin->filter, plugin->filter_type, plugin->cutoff_freq, plugin->resonance, plugin->gain, plugin->sample_rate);
    
    // Allocate temporary buffer for processing
    plugin->temp_buffer_size = 0;
    plugin->temp_buffer = NULL;
    
    return true;
}

static void deactivate(audio_filter_plugin_t *plugin) {
    // Clean up any allocated resources
    if (plugin->temp_buffer) {
        free(plugin->temp_buffer);
        plugin->temp_buffer = NULL;
        plugin->temp_buffer_size = 0;
    }
}

static bool start_processing(const audio_filter_plugin_t *plugin) {
    return true;
}

static void stop_processing(const audio_filter_plugin_t *plugin) {
    // Nothing to do
}

static void reset(audio_filter_plugin_t *plugin) {
    filter_reset(&plugin->filter);
}

void update_filter_parameters(audio_filter_plugin_t *plugin) {
    filter_set_parameters(&plugin->filter, plugin->filter_type, plugin->cutoff_freq, plugin->resonance, plugin->gain);
    filter_set_sample_rate(&plugin->filter, plugin->sample_rate);
}

static clap_process_status process(audio_filter_plugin_t *plugin, const clap_process_t *process) {
    const uint32_t nframes = process->frames_count;
    
    // Handle events
    uint32_t num_events = process->in_events->size(process->in_events);
    for (uint32_t i = 0; i < num_events; ++i) {
        const clap_event_header_t *event = process->in_events->get(process->in_events, i);
        
        if (event->type == CLAP_EVENT_PARAM_VALUE) {
            const clap_event_param_value_t *param_event = (const clap_event_param_value_t *)event;
            switch (param_event->param_id) {
                case PARAM_CUTOFF:
                    plugin->cutoff_freq = param_event->value;
                    update_filter_parameters(plugin);
                    break;
                case PARAM_RESONANCE:
                    plugin->resonance = param_event->value;
                    update_filter_parameters(plugin);
                    break;
                case PARAM_GAIN:
                    plugin->gain = param_event->value;
                    update_filter_parameters(plugin);
                    break;
                case PARAM_TYPE:
                    plugin->filter_type = (filter_type_t)param_event->value;
                    update_filter_parameters(plugin);
                    break;
                case PARAM_ENABLED:
                    plugin->enabled = param_event->value > 0.5f;
                    break;
            }
        }
    }
    
    // Process audio
    if (process->audio_inputs_count >= 1 && process->audio_outputs_count >= 1) {
        const clap_audio_buffer_t *input = &process->audio_inputs[0];
        const clap_audio_buffer_t *output = &process->audio_outputs[0];
        
        // Ensure we have enough buffer space
        if (plugin->temp_buffer_size < nframes) {
            if (plugin->temp_buffer) {
                free(plugin->temp_buffer);
            }
            plugin->temp_buffer = (float *)malloc(nframes * sizeof(float));
            plugin->temp_buffer_size = nframes;
        }
        
        if (plugin->enabled && input->data32 && output->data32) {
            // Process each channel
            for (uint32_t ch = 0; ch < output->channel_count; ++ch) {
                if (ch < input->channel_count && input->data32[ch] && output->data32[ch]) {
                    if (plugin->filter.initialized) {
                        filter_process_block(&plugin->filter, input->data32[ch], output->data32[ch], nframes);
                    } else {
                        // Just copy if filter not initialized
                        memcpy(output->data32[ch], input->data32[ch], nframes * sizeof(float));
                    }
                }
            }
            
            // Copy first channel audio for visualization (if not already copied)
            if (input->data32[0] && plugin->temp_buffer) {
                memcpy(plugin->temp_buffer, input->data32[0], nframes * sizeof(float));
            }
        } else if (!plugin->enabled && input->data32 && output->data32) {
            // Bypass - copy input to output
            for (uint32_t ch = 0; ch < output->channel_count; ++ch) {
                if (ch < input->channel_count && input->data32[ch] && output->data32[ch]) {
                    memcpy(output->data32[ch], input->data32[ch], nframes * sizeof(float));
                }
            }
            
            // Copy first channel audio for visualization (if not already copied)
            if (input->data32[0] && plugin->temp_buffer) {
                memcpy(plugin->temp_buffer, input->data32[0], nframes * sizeof(float));
            }
        }
    }
    
    return CLAP_PROCESS_CONTINUE;
}

static const void *get_extension(const audio_filter_plugin_t *plugin, const char *id) {
    if (!strcmp(id, CLAP_EXT_PARAMS)) {
        return &s_plugin_params;
    }
    if (!strcmp(id, CLAP_EXT_STATE)) {
        return &s_plugin_state;
    }
    if (!strcmp(id, CLAP_EXT_LATENCY)) {
        return &s_plugin_latency;
    }
    if (!strcmp(id, CLAP_EXT_AUDIO_PORTS)) {
        return &s_plugin_audio_ports;
    }
    // TODO: Re-enable these after updating to match CLAP API
    // if (!strcmp(id, CLAP_EXT_SURROUND)) {
    //     return &s_plugin_surround;
    // }
    // if (!strcmp(id, CLAP_EXT_AMBISONIC)) {
    //     return &s_plugin_ambisonic;
    // }
    // if (!strcmp(id, CLAP_EXT_GUI)) {
    //     return &s_plugin_gui;
    // }

    return NULL;
}

static void on_main_thread(const audio_filter_plugin_t *plugin) {
    // Called on main thread - can be used for host communication
    // Note: Sample rate changes are handled via activate() callback
}

// Export plugin functions
clap_plugin_t *audio_filter_plugin_create(const clap_host_t *host) {
    audio_filter_plugin_t *plugin = (audio_filter_plugin_t *)calloc(1, sizeof(audio_filter_plugin_t));
    if (!plugin) {
        return NULL;
    }
    
    // Initialize default parameters
    plugin->host = host;
    plugin->cutoff_freq = 1000.0f;      // 1 kHz
    plugin->resonance = 1.0f;           // Q = 1
    plugin->gain = 0.0f;                // 0 dB
    plugin->filter_type = FILTER_TYPE_LOWPASS;
    plugin->enabled = true;
    plugin->sample_rate = 44100.0f;     // Default sample rate
    
    // Initialize filter
    filter_init(&plugin->filter, plugin->filter_type, plugin->cutoff_freq, plugin->resonance, plugin->gain, plugin->sample_rate);
    
    // Set plugin structure
    plugin->plugin.desc = &s_plugin_desc;
    plugin->plugin.plugin_data = plugin;
    plugin->plugin.init = audio_filter_init;
    plugin->plugin.destroy = audio_filter_destroy;
    plugin->plugin.activate = audio_filter_activate;
    plugin->plugin.deactivate = audio_filter_deactivate;
    plugin->plugin.start_processing = audio_filter_start_processing;
    plugin->plugin.stop_processing = audio_filter_stop_processing;
    plugin->plugin.reset = audio_filter_reset;
    plugin->plugin.process = audio_filter_process;
    plugin->plugin.get_extension = audio_filter_get_extension;
    plugin->plugin.on_main_thread = audio_filter_on_main_thread;
    
    return &plugin->plugin;
}

// Activation function
static bool audio_filter_activate(const clap_plugin_t *plugin, double sample_rate, uint32_t min_frames_count, uint32_t max_frames_count) {
    audio_filter_plugin_t *p = (audio_filter_plugin_t *)plugin->plugin_data;
    p->sample_rate = (float)sample_rate;
    update_filter_parameters(p);
    return true;
}