#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "DSP/StemSeparator.h"

StemperatorEditor::StemperatorEditor (StemperatorProcessor& p)
    : AudioProcessorEditor (&p), processor (p)
{
    // Apply premium look and feel
    setLookAndFeel (&premiumLookAndFeel);

    // Initialize format manager for audio file loading
    formatManager = std::make_unique<juce::AudioFormatManager>();
    formatManager->registerBasicFormats();

    // Setup menu bar for standalone mode
    if (isStandalone())
    {
        commandManager.registerAllCommandsForTarget (this);
        menuBar = std::make_unique<juce::MenuBarComponent> (this);
        addAndMakeVisible (*menuBar);

        // Setup transport controls
        setupTransportControls();
    }

    // Create stem channels with premium colors
    const char* names[] = { "VOCALS", "DRUMS", "BASS", "OTHER" };
    const char* gainIDs[] = { "vocalsGain", "drumsGain", "bassGain", "otherGain" };
    const char* muteIDs[] = { "vocalsMute", "drumsMute", "bassMute", "otherMute" };
    const char* soloIDs[] = { "vocalsSolo", "drumsSolo", "bassSolo", "otherSolo" };

    for (int i = 0; i < 4; ++i)
    {
        stemChannels[i] = std::make_unique<StemChannel> (names[i], stemColours[static_cast<size_t> (i)]);
        stemChannels[i]->attachToParameters (processor.getParameters(), gainIDs[i], muteIDs[i], soloIDs[i]);
        addAndMakeVisible (*stemChannels[i]);
    }

    // Visualizer
    addAndMakeVisible (visualizer);

    // Master slider - vertical fader style
    setupSlider (masterSlider, PremiumLookAndFeel::Colours::accent);
    masterSlider.setSliderStyle (juce::Slider::LinearVertical);
    masterSlider.setRange (-60.0, 12.0, 0.1);
    masterSlider.setTextValueSuffix (" dB");

    masterLabel.setJustificationType (juce::Justification::centred);
    masterLabel.setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textBright);
    addAndMakeVisible (masterLabel);

    masterAttachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment> (
        processor.getParameters(), "masterGain", masterSlider);

    // Focus controls - rotary knobs
    setupKnob (vocalsFocusSlider, vocalsFocusLabel, "VOCAL FOCUS", stemColours[0]);
    setupKnob (bassCutoffSlider, bassCutoffLabel, "BASS CUTOFF", stemColours[2]);
    setupKnob (drumSensSlider, drumSensLabel, "DRUM SENS", stemColours[1]);

    vocalsFocusAttachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment> (
        processor.getParameters(), "vocalsFocus", vocalsFocusSlider);
    bassCutoffAttachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment> (
        processor.getParameters(), "bassCutoff", bassCutoffSlider);
    drumSensAttachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment> (
        processor.getParameters(), "drumSensitivity", drumSensSlider);

    // Quality selector
    qualityBox.addItem ("Fast", 1);
    qualityBox.addItem ("Balanced", 2);
    qualityBox.addItem ("Best", 3);
    addAndMakeVisible (qualityBox);

    qualityLabel.setJustificationType (juce::Justification::centred);
    qualityLabel.setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textMid);
    addAndMakeVisible (qualityLabel);

    qualityAttachment = std::make_unique<juce::AudioProcessorValueTreeState::ComboBoxAttachment> (
        processor.getParameters(), "quality", qualityBox);

    // Title - large and prominent
    titleLabel.setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textBright);
    titleLabel.setJustificationType (juce::Justification::centredLeft);
    addAndMakeVisible (titleLabel);

    // Subtitle - show GPU and AI status
    juce::String subtitle = "AI-POWERED STEM SEPARATION";
    if (processor.isUsingGPU())
        subtitle += " | GPU: " + processor.getGPUInfo();
    else
        subtitle += " | CPU";

    // Add Demucs status
    if (processor.isDemucsAvailable())
        subtitle += " | Demucs: Ready";

    subtitleLabel.setText (subtitle, juce::dontSendNotification);
    subtitleLabel.setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textDim);
    subtitleLabel.setJustificationType (juce::Justification::centredLeft);
    addAndMakeVisible (subtitleLabel);

    // Brand label (right-aligned)
    brandLabel.setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::accent);
    brandLabel.setJustificationType (juce::Justification::centredRight);
    addAndMakeVisible (brandLabel);

    // Start timer for level updates
    startTimerHz (30);

    // Resizable with wide range for small laptops to large monitors
    setResizable (true, true);
    setResizeLimits (600, 400, 1600, 1000);
    setSize (850, 550);
}

StemperatorEditor::~StemperatorEditor()
{
    setLookAndFeel (nullptr);
    stopTimer();
    transportSource.setSource (nullptr);
}

//==============================================================================
// Standalone detection
bool StemperatorEditor::isStandalone() const
{
    return juce::PluginHostType().isInterAppAudioConnected() == false
        && juce::JUCEApplicationBase::isStandaloneApp();
}

//==============================================================================
// MenuBarModel implementation
juce::StringArray StemperatorEditor::getMenuBarNames()
{
    return { "File", "Export", "Help" };
}

juce::PopupMenu StemperatorEditor::getMenuForIndex (int menuIndex, const juce::String&)
{
    juce::PopupMenu menu;

    if (menuIndex == 0)  // File menu
    {
        menu.addCommandItem (&commandManager, cmdLoadFile);
        menu.addSeparator();
        menu.addCommandItem (&commandManager, cmdPlay);
        menu.addCommandItem (&commandManager, cmdStop);
    }
    else if (menuIndex == 1)  // Export menu
    {
        menu.addCommandItem (&commandManager, cmdExportAllStems);
        menu.addSeparator();
        menu.addCommandItem (&commandManager, cmdExportVocals);
        menu.addCommandItem (&commandManager, cmdExportDrums);
        menu.addCommandItem (&commandManager, cmdExportBass);
        menu.addCommandItem (&commandManager, cmdExportOther);
    }
    else if (menuIndex == 2)  // Help menu
    {
        menu.addCommandItem (&commandManager, cmdAbout);
    }

    return menu;
}

void StemperatorEditor::menuItemSelected (int, int)
{
    // Handled by command manager
}

//==============================================================================
// ApplicationCommandTarget implementation
void StemperatorEditor::getAllCommands (juce::Array<juce::CommandID>& commands)
{
    commands.addArray ({
        cmdLoadFile,
        cmdExportAllStems,
        cmdExportVocals,
        cmdExportDrums,
        cmdExportBass,
        cmdExportOther,
        cmdPlay,
        cmdStop,
        cmdAbout
    });
}

void StemperatorEditor::getCommandInfo (juce::CommandID commandID, juce::ApplicationCommandInfo& result)
{
    switch (commandID)
    {
        case cmdLoadFile:
            result.setInfo ("Load Audio File...", "Load an audio file for stem separation", "File", 0);
            result.addDefaultKeypress ('o', juce::ModifierKeys::commandModifier);
            break;
        case cmdExportAllStems:
            result.setInfo ("Export All Stems...", "Export all separated stems to files", "Export", 0);
            result.addDefaultKeypress ('e', juce::ModifierKeys::commandModifier | juce::ModifierKeys::shiftModifier);
            result.setActive (hasLoadedFile);
            break;
        case cmdExportVocals:
            result.setInfo ("Export Vocals...", "Export vocals stem", "Export", 0);
            result.setActive (hasLoadedFile);
            break;
        case cmdExportDrums:
            result.setInfo ("Export Drums...", "Export drums stem", "Export", 0);
            result.setActive (hasLoadedFile);
            break;
        case cmdExportBass:
            result.setInfo ("Export Bass...", "Export bass stem", "Export", 0);
            result.setActive (hasLoadedFile);
            break;
        case cmdExportOther:
            result.setInfo ("Export Other...", "Export other/instruments stem", "Export", 0);
            result.setActive (hasLoadedFile);
            break;
        case cmdPlay:
            result.setInfo ("Play", "Start playback", "Transport", 0);
            result.addDefaultKeypress (juce::KeyPress::spaceKey, juce::ModifierKeys::noModifiers);
            result.setActive (hasLoadedFile);
            break;
        case cmdStop:
            result.setInfo ("Stop", "Stop playback", "Transport", 0);
            result.setActive (hasLoadedFile);
            break;
        case cmdAbout:
            result.setInfo ("About Stemperator", "Show application info", "Help", 0);
            break;
        default:
            break;
    }
}

bool StemperatorEditor::perform (const juce::ApplicationCommandTarget::InvocationInfo& info)
{
    switch (info.commandID)
    {
        case cmdLoadFile:
            loadAudioFile();
            return true;
        case cmdExportAllStems:
            exportStems (-1);
            return true;
        case cmdExportVocals:
            exportStems (0);
            return true;
        case cmdExportDrums:
            exportStems (1);
            return true;
        case cmdExportBass:
            exportStems (2);
            return true;
        case cmdExportOther:
            exportStems (3);
            return true;
        case cmdPlay:
            transportSource.start();
            return true;
        case cmdStop:
            transportSource.stop();
            transportSource.setPosition (0.0);
            return true;
        case cmdAbout:
            juce::AlertWindow::showMessageBoxAsync (
                juce::MessageBoxIconType::InfoIcon,
                "About Stemperator",
                "Stemperator v1.0\n\n"
                "AI-Powered Stem Separation\n"
                "by flarkAUDIO\n\n"
                "Separates audio into:\n"
                "- Vocals\n"
                "- Drums\n"
                "- Bass\n"
                "- Other instruments");
            return true;
        default:
            return false;
    }
}

//==============================================================================
// File handling
void StemperatorEditor::loadAudioFile()
{
    // Use native file dialog with common audio formats including MP3
    fileChooser = std::make_unique<juce::FileChooser> (
        "Select an audio file to separate...",
        juce::File::getSpecialLocation (juce::File::userMusicDirectory),
        "*.wav;*.mp3;*.flac;*.aiff;*.ogg;*.m4a;*.wma",
        true);  // useNativeDialogs = true for speed

    auto chooserFlags = juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles;

    fileChooser->launchAsync (chooserFlags, [this] (const juce::FileChooser& c)
    {
        auto file = c.getResult();

        if (file == juce::File())
            return;

        // Update UI immediately
        if (fileNameLabel)
            fileNameLabel->setText ("Loading: " + file.getFileName(), juce::dontSendNotification);

        auto* reader = formatManager->createReaderFor (file);
        if (reader != nullptr)
        {
            currentAudioFile = file;
            hasLoadedFile = true;
            loadedSampleRate = reader->sampleRate;

            // Load entire file into buffer for processing
            loadedAudioBuffer.setSize ((int) reader->numChannels, (int) reader->lengthInSamples);
            reader->read (&loadedAudioBuffer, 0, (int) reader->lengthInSamples, 0, true, true);

            // Setup transport source for playback
            readerSource = std::make_unique<juce::AudioFormatReaderSource> (reader, true);
            transportSource.setSource (readerSource.get(), 0, nullptr, reader->sampleRate);

            // Update UI
            if (fileNameLabel)
                fileNameLabel->setText (file.getFileName(), juce::dontSendNotification);

            commandManager.commandStatusChanged();

            // Show duration in time label
            auto duration = loadedAudioBuffer.getNumSamples() / reader->sampleRate;
            auto minutes = (int) (duration / 60.0);
            auto seconds = (int) duration % 60;

            if (timeLabel)
                timeLabel->setText ("0:00 / " + juce::String (minutes) + ":" +
                    juce::String (seconds).paddedLeft ('0', 2), juce::dontSendNotification);
        }
        else
        {
            juce::AlertWindow::showMessageBoxAsync (
                juce::MessageBoxIconType::WarningIcon,
                "Load Failed",
                "Could not load: " + file.getFileName() + "\n\n"
                "Make sure it's a supported audio format.");
        }
    });
}

void StemperatorEditor::exportStems (int stemIndex)
{
    if (! hasLoadedFile)
    {
        juce::AlertWindow::showMessageBoxAsync (
            juce::MessageBoxIconType::WarningIcon,
            "No File Loaded",
            "Please load an audio file first using File > Load Audio File");
        return;
    }

    juce::String title = (stemIndex < 0) ? "Select folder for stem export" : "Save " + juce::String (StemperatorProcessor::stemNames[stemIndex]) + " stem";
    juce::String defaultName = currentAudioFile.getFileNameWithoutExtension();

    if (stemIndex < 0)
    {
        // Export all stems - choose folder
        fileChooser = std::make_unique<juce::FileChooser> (
            title,
            currentAudioFile.getParentDirectory().getChildFile (defaultName + "_stems"),
            "",
            true);  // useNativeDialogs

        fileChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectDirectories,
            [this] (const juce::FileChooser& c)
            {
                auto folder = c.getResult();

                if (folder == juce::File())
                    return;

                // Create folder if needed
                folder.createDirectory();

                // Show progress
                if (fileNameLabel)
                    fileNameLabel->setText ("Separating stems...", juce::dontSendNotification);

                // Copy data for thread safety
                auto bufferCopy = std::make_shared<juce::AudioBuffer<float>> (loadedAudioBuffer);
                auto sampleRate = loadedSampleRate;

                juce::Thread::launch ([this, folder, bufferCopy, sampleRate]()
                {
                    try
                    {
                        auto startTime = juce::Time::getMillisecondCounterHiRes();

                        // Create a dedicated separator for this export (thread-safe)
                        StemSeparator separator;

                        const int totalSamples = bufferCopy->getNumSamples();
                        const int numChannels = std::min (2, bufferCopy->getNumChannels());
                        const int blockSize = 2048;  // Process in blocks
                        const int totalBlocks = (totalSamples + blockSize - 1) / blockSize;

                        // IMPORTANT: Prepare the separator with correct sample rate and block size
                        separator.prepare (sampleRate, blockSize);

                        // Prepare output buffers for all stems
                        std::array<juce::AudioBuffer<float>, 4> outputStems;
                        for (auto& stem : outputStems)
                        {
                            stem.setSize (numChannels, totalSamples);
                            stem.clear();
                        }

                        // Stats tracking
                        std::array<float, 4> peakLevels = { 0.0f, 0.0f, 0.0f, 0.0f };
                        const char* stemNames[] = { "Vocals", "Drums", "Bass", "Other" };

                        // Process in blocks with overlap handling
                        int blockCount = 0;
                        for (int startSample = 0; startSample < totalSamples; startSample += blockSize)
                        {
                            int samplesToProcess = std::min (blockSize, totalSamples - startSample);

                            // Create a temporary buffer for this block
                            juce::AudioBuffer<float> blockBuffer (numChannels, samplesToProcess);
                            for (int ch = 0; ch < numChannels; ++ch)
                            {
                                blockBuffer.copyFrom (ch, 0, *bufferCopy, ch, startSample, samplesToProcess);
                            }

                            // Process the block
                            separator.process (blockBuffer);
                            auto& stems = separator.getStems();

                            // Copy results to output buffers and track peak levels
                            for (int stemIdx = 0; stemIdx < 4; ++stemIdx)
                            {
                                int samplesToCopy = std::min (samplesToProcess, stems[stemIdx].getNumSamples());
                                for (int ch = 0; ch < numChannels; ++ch)
                                {
                                    if (samplesToCopy > 0)
                                    {
                                        outputStems[stemIdx].copyFrom (ch, startSample, stems[stemIdx], ch, 0, samplesToCopy);
                                        // Track peak level
                                        float peak = stems[stemIdx].getMagnitude (ch, 0, samplesToCopy);
                                        peakLevels[stemIdx] = std::max (peakLevels[stemIdx], peak);
                                    }
                                }
                            }

                            // Update progress every 10 blocks
                            blockCount++;
                            if (blockCount % 10 == 0 || blockCount == totalBlocks)
                            {
                                float progress = (float) blockCount / (float) totalBlocks;
                                int percent = (int) (progress * 100.0f);
                                double elapsed = (juce::Time::getMillisecondCounterHiRes() - startTime) / 1000.0;
                                double eta = (elapsed / progress) - elapsed;

                                juce::String status = "Separating: " + juce::String (percent) + "% | "
                                    + "ETA: " + juce::String ((int) eta) + "s";

                                juce::MessageManager::callAsync ([this, status]()
                                {
                                    if (fileNameLabel)
                                        fileNameLabel->setText (status, juce::dontSendNotification);
                                });
                            }
                        }

                        // Use the processed stems for output
                        auto& stems = outputStems;

                        // Update status - now saving
                        juce::MessageManager::callAsync ([this]()
                        {
                            if (fileNameLabel)
                                fileNameLabel->setText ("Saving stems...", juce::dontSendNotification);
                        });

                        // Save each stem with progress
                        juce::WavAudioFormat wavFormat;
                        const char* stemFileNames[] = { "vocals", "drums", "bass", "other" };
                        int savedCount = 0;
                        std::array<juce::int64, 4> fileSizes = { 0, 0, 0, 0 };

                        for (int i = 0; i < 4; ++i)
                        {
                            if (stems[i].getNumSamples() == 0)
                                continue;

                            // Update progress per stem
                            juce::MessageManager::callAsync ([this, i, stemNames]()
                            {
                                if (fileNameLabel)
                                    fileNameLabel->setText (juce::String ("Saving: ") + stemNames[i] + "...", juce::dontSendNotification);
                            });

                            auto stemFile = folder.getChildFile (juce::String (stemFileNames[i]) + ".wav");
                            stemFile.deleteFile();

                            auto outputStream = std::make_unique<juce::FileOutputStream> (stemFile);
                            if (outputStream->openedOk())
                            {
                                auto writer = std::unique_ptr<juce::AudioFormatWriter> (
                                    wavFormat.createWriterFor (
                                        outputStream.release(),
                                        sampleRate,
                                        static_cast<unsigned int> (stems[i].getNumChannels()),
                                        24, {}, 0));

                                if (writer)
                                {
                                    writer->writeFromAudioSampleBuffer (stems[i], 0, stems[i].getNumSamples());
                                    savedCount++;
                                    fileSizes[i] = stemFile.getSize();
                                }
                            }
                        }

                        // Calculate processing stats
                        double processingTime = (juce::Time::getMillisecondCounterHiRes() - startTime) / 1000.0;
                        double audioDuration = (double) totalSamples / sampleRate;
                        double speedMultiplier = audioDuration / processingTime;

                        // Build stats string
                        juce::String statsStr = "Separation complete!\n\n";
                        statsStr += "Duration: " + juce::String (audioDuration, 1) + "s processed in "
                                 + juce::String (processingTime, 1) + "s ("
                                 + juce::String (speedMultiplier, 1) + "x realtime)\n\n";
                        statsStr += "Stem Statistics:\n";

                        for (int i = 0; i < 4; ++i)
                        {
                            float peakDb = juce::Decibels::gainToDecibels (peakLevels[i], -60.0f);
                            juce::String sizeStr = juce::File::descriptionOfSizeInBytes (fileSizes[i]);
                            statsStr += "  " + juce::String (stemNames[i]) + ": Peak "
                                     + juce::String (peakDb, 1) + " dB | " + sizeStr + "\n";
                        }

                        statsStr += "\nExported to:\n" + folder.getFullPathName();

                        juce::MessageManager::callAsync ([this, folder, savedCount, statsStr]()
                        {
                            if (fileNameLabel)
                                fileNameLabel->setText (currentAudioFile.getFileName(), juce::dontSendNotification);

                            juce::AlertWindow::showMessageBoxAsync (
                                juce::MessageBoxIconType::InfoIcon,
                                "Export Complete",
                                statsStr);
                        });
                    }
                    catch (...)
                    {
                        juce::MessageManager::callAsync ([this]()
                        {
                            if (fileNameLabel)
                                fileNameLabel->setText (currentAudioFile.getFileName(), juce::dontSendNotification);

                            juce::AlertWindow::showMessageBoxAsync (
                                juce::MessageBoxIconType::WarningIcon,
                                "Export Failed",
                                "An error occurred during stem separation.");
                        });
                    }
                });
            });
    }
    else
    {
        // Export single stem
        fileChooser = std::make_unique<juce::FileChooser> (
            title,
            currentAudioFile.getParentDirectory().getChildFile (
                defaultName + "_" + StemperatorProcessor::stemNames[stemIndex] + ".wav"),
            "*.wav",
            true);  // useNativeDialogs

        fileChooser->launchAsync (juce::FileBrowserComponent::saveMode,
            [this, stemIndex] (const juce::FileChooser& c)
            {
                auto file = c.getResult();

                if (file == juce::File())
                    return;

                // Show progress
                if (fileNameLabel)
                    fileNameLabel->setText ("Exporting " + juce::String (StemperatorProcessor::stemNames[stemIndex]) + "...", juce::dontSendNotification);

                auto bufferCopy = std::make_shared<juce::AudioBuffer<float>> (loadedAudioBuffer);
                auto sampleRate = loadedSampleRate;

                juce::Thread::launch ([this, stemIndex, file, bufferCopy, sampleRate]()
                {
                    try
                    {
                        // Create a dedicated separator for this export (thread-safe)
                        StemSeparator separator;

                        const int totalSamples = bufferCopy->getNumSamples();
                        const int numChannels = std::min (2, bufferCopy->getNumChannels());
                        const int blockSize = 2048;

                        // Prepare the separator
                        separator.prepare (sampleRate, blockSize);

                        // Output buffer for this stem
                        juce::AudioBuffer<float> outputStem (numChannels, totalSamples);
                        outputStem.clear();

                        // Process in blocks
                        for (int startSample = 0; startSample < totalSamples; startSample += blockSize)
                        {
                            int samplesToProcess = std::min (blockSize, totalSamples - startSample);

                            juce::AudioBuffer<float> blockBuffer (numChannels, samplesToProcess);
                            for (int ch = 0; ch < numChannels; ++ch)
                                blockBuffer.copyFrom (ch, 0, *bufferCopy, ch, startSample, samplesToProcess);

                            separator.process (blockBuffer);
                            auto& stems = separator.getStems();

                            int samplesToCopy = std::min (samplesToProcess, stems[stemIndex].getNumSamples());
                            for (int ch = 0; ch < numChannels; ++ch)
                            {
                                if (samplesToCopy > 0)
                                    outputStem.copyFrom (ch, startSample, stems[stemIndex], ch, 0, samplesToCopy);
                            }
                        }

                        juce::WavAudioFormat wavFormat;
                        file.deleteFile();

                        auto outputStream = std::make_unique<juce::FileOutputStream> (file);
                        if (outputStream->openedOk() && outputStem.getNumSamples() > 0)
                        {
                            auto writer = std::unique_ptr<juce::AudioFormatWriter> (
                                wavFormat.createWriterFor (
                                    outputStream.release(),
                                    sampleRate,
                                    static_cast<unsigned int> (outputStem.getNumChannels()),
                                    24, {}, 0));

                            if (writer)
                                writer->writeFromAudioSampleBuffer (outputStem, 0, outputStem.getNumSamples());
                        }

                        juce::MessageManager::callAsync ([this, file]()
                        {
                            if (fileNameLabel)
                                fileNameLabel->setText (currentAudioFile.getFileName(), juce::dontSendNotification);

                            juce::AlertWindow::showMessageBoxAsync (
                                juce::MessageBoxIconType::InfoIcon,
                                "Export Complete",
                                "Stem exported to:\n" + file.getFullPathName());
                        });
                    }
                    catch (...)
                    {
                        juce::MessageManager::callAsync ([this]()
                        {
                            if (fileNameLabel)
                                fileNameLabel->setText (currentAudioFile.getFileName(), juce::dontSendNotification);

                            juce::AlertWindow::showMessageBoxAsync (
                                juce::MessageBoxIconType::WarningIcon,
                                "Export Failed",
                                "An error occurred during export.");
                        });
                    }
                });
            });
    }
}

void StemperatorEditor::showExportProgress (const juce::String& message)
{
    // Simple progress indication - could be replaced with a progress bar
    DBG (message);
}

//==============================================================================
// Transport controls
void StemperatorEditor::setupTransportControls()
{
    playButton = std::make_unique<juce::TextButton> ("Play");
    playButton->onClick = [this]() { commandManager.invokeDirectly (cmdPlay, false); };
    addAndMakeVisible (*playButton);

    stopButton = std::make_unique<juce::TextButton> ("Stop");
    stopButton->onClick = [this]() { commandManager.invokeDirectly (cmdStop, false); };
    addAndMakeVisible (*stopButton);

    fileNameLabel = std::make_unique<juce::Label> ("", "No file loaded");
    fileNameLabel->setJustificationType (juce::Justification::centredLeft);
    fileNameLabel->setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textMid);
    addAndMakeVisible (*fileNameLabel);

    timeLabel = std::make_unique<juce::Label> ("", "0:00 / 0:00");
    timeLabel->setJustificationType (juce::Justification::centredRight);
    timeLabel->setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textDim);
    addAndMakeVisible (*timeLabel);

    positionSlider = std::make_unique<juce::Slider> (juce::Slider::LinearHorizontal, juce::Slider::NoTextBox);
    positionSlider->setRange (0.0, 1.0);
    positionSlider->onValueChange = [this]()
    {
        if (hasLoadedFile && ! transportSource.isPlaying())
        {
            auto length = transportSource.getLengthInSeconds();
            transportSource.setPosition (positionSlider->getValue() * length);
        }
    };
    addAndMakeVisible (*positionSlider);
}

void StemperatorEditor::updateTransportDisplay()
{
    if (! isStandalone() || ! hasLoadedFile)
        return;

    auto position = transportSource.getCurrentPosition();
    auto length = transportSource.getLengthInSeconds();

    if (length > 0)
    {
        positionSlider->setValue (position / length, juce::dontSendNotification);

        auto formatTime = [] (double seconds) {
            int mins = (int) (seconds / 60.0);
            int secs = (int) seconds % 60;
            return juce::String (mins) + ":" + juce::String (secs).paddedLeft ('0', 2);
        };

        timeLabel->setText (formatTime (position) + " / " + formatTime (length), juce::dontSendNotification);
    }
}

void StemperatorEditor::setupSlider (juce::Slider& slider, juce::Colour colour)
{
    slider.setColour (juce::Slider::thumbColourId, colour);
    slider.setColour (juce::Slider::trackColourId, colour.darker (0.3f));
    slider.setColour (juce::Slider::textBoxTextColourId, PremiumLookAndFeel::Colours::textBright);
    slider.setColour (juce::Slider::textBoxOutlineColourId, juce::Colours::transparentBlack);
    slider.setColour (juce::Slider::textBoxBackgroundColourId, PremiumLookAndFeel::Colours::bgPanel);
    addAndMakeVisible (slider);
}

void StemperatorEditor::setupKnob (juce::Slider& slider, juce::Label& label, const juce::String& text, juce::Colour colour)
{
    slider.setSliderStyle (juce::Slider::RotaryHorizontalVerticalDrag);
    setupSlider (slider, colour);

    label.setText (text, juce::dontSendNotification);
    label.setJustificationType (juce::Justification::centred);
    label.setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textMid);
    addAndMakeVisible (label);
}

void StemperatorEditor::updateFontSizes()
{
    float scale = getScaleFactor();

    // Title fonts scale with window
    titleLabel.setFont (juce::FontOptions (32.0f * scale).withStyle ("Bold"));
    subtitleLabel.setFont (juce::FontOptions (11.0f * scale));
    brandLabel.setFont (juce::FontOptions (14.0f * scale).withStyle ("Bold"));
    masterLabel.setFont (juce::FontOptions (13.0f * scale).withStyle ("Bold"));

    // Control labels
    float labelSize = 10.0f * scale;
    vocalsFocusLabel.setFont (juce::FontOptions (labelSize).withStyle ("Bold"));
    bassCutoffLabel.setFont (juce::FontOptions (labelSize).withStyle ("Bold"));
    drumSensLabel.setFont (juce::FontOptions (labelSize).withStyle ("Bold"));
    qualityLabel.setFont (juce::FontOptions (11.0f * scale).withStyle ("Bold"));

    // Slider text boxes scale
    int textBoxWidth = scaled (60);
    int textBoxHeight = scaled (20);
    masterSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, textBoxWidth, textBoxHeight);

    int knobTextHeight = scaled (16);
    vocalsFocusSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, textBoxWidth, knobTextHeight);
    bassCutoffSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, textBoxWidth, knobTextHeight);
    drumSensSlider.setTextBoxStyle (juce::Slider::TextBoxBelow, false, textBoxWidth, knobTextHeight);
}

void StemperatorEditor::paint (juce::Graphics& g)
{
    float scale = getScaleFactor();
    int headerHeight = scaled (65);
    int footerHeight = scaled (95);

    // Premium gradient background
    juce::ColourGradient bgGradient (
        PremiumLookAndFeel::Colours::bgDark, 0, 0,
        PremiumLookAndFeel::Colours::bgMid, 0, (float) getHeight(), false);
    bgGradient.addColour (0.5, PremiumLookAndFeel::Colours::bgLight.interpolatedWith (
        PremiumLookAndFeel::Colours::bgDark, 0.7f));
    g.setGradientFill (bgGradient);
    g.fillAll();

    // Subtle grid pattern for depth (scales with size)
    int gridSpacing = juce::jmax (2, scaled (3));
    g.setColour (PremiumLookAndFeel::Colours::textDim.withAlpha (0.03f));
    for (int y = 0; y < getHeight(); y += gridSpacing)
        g.drawHorizontalLine (y, 0, (float) getWidth());

    // Header separator with accent glow
    juce::ColourGradient separatorGradient (
        PremiumLookAndFeel::Colours::accent.withAlpha (0.0f), 0, (float) headerHeight,
        PremiumLookAndFeel::Colours::accent.withAlpha (0.5f), getWidth() * 0.5f, (float) headerHeight, false);
    separatorGradient.addColour (1.0, PremiumLookAndFeel::Colours::accent.withAlpha (0.0f));
    g.setGradientFill (separatorGradient);
    g.fillRect (0, headerHeight, getWidth(), juce::jmax (1, scaled (2)));

    // Footer separator
    int footerTop = getHeight() - footerHeight;
    g.setGradientFill (separatorGradient);
    g.fillRect (0, footerTop, getWidth(), 1);

    // Panel backgrounds for stem channels area
    int margin = scaled (15);
    int channelWidth = scaled (95);
    auto channelsPanelArea = juce::Rectangle<int> (margin, headerHeight + scaled (8),
                                                   channelWidth * 4 + scaled (20),
                                                   getHeight() - headerHeight - footerHeight - scaled (16));
    g.setColour (PremiumLookAndFeel::Colours::bgPanel.withAlpha (0.3f));
    g.fillRoundedRectangle (channelsPanelArea.toFloat(), scaled (8.0f));
}

void StemperatorEditor::resized()
{
    // Update font sizes for current scale
    updateFontSizes();

    float scale = getScaleFactor();
    auto bounds = getLocalBounds();

    // Menu bar for standalone mode
    int menuBarHeight = 0;
    if (isStandalone() && menuBar)
    {
        menuBarHeight = scaled (24);
        menuBar->setBounds (bounds.removeFromTop (menuBarHeight));
    }

    // Transport bar for standalone mode
    int transportHeight = 0;
    if (isStandalone() && playButton)
    {
        transportHeight = scaled (36);
        auto transportArea = bounds.removeFromTop (transportHeight);
        transportArea = transportArea.reduced (scaled (10), scaled (4));

        // Play/Stop buttons
        playButton->setBounds (transportArea.removeFromLeft (scaled (60)));
        transportArea.removeFromLeft (scaled (5));
        stopButton->setBounds (transportArea.removeFromLeft (scaled (60)));
        transportArea.removeFromLeft (scaled (10));

        // Time label on the right
        timeLabel->setBounds (transportArea.removeFromRight (scaled (100)));
        transportArea.removeFromRight (scaled (10));

        // File name and position slider
        fileNameLabel->setBounds (transportArea.removeFromTop (scaled (14)));
        positionSlider->setBounds (transportArea);
    }

    // Scaled dimensions
    int headerHeight = scaled (65);
    int footerHeight = scaled (95);
    int margin = scaled (15);
    int spacing = scaled (10);

    // Header area
    auto header = bounds.removeFromTop (headerHeight);
    auto headerLeft = header.removeFromLeft (header.getWidth() / 2).reduced (scaled (20), scaled (12));
    titleLabel.setBounds (headerLeft.removeFromTop (scaled (32)));
    subtitleLabel.setBounds (headerLeft);

    auto headerRight = header.reduced (scaled (20), scaled (20));
    brandLabel.setBounds (headerRight);

    // Footer with focus controls
    auto footer = bounds.removeFromBottom (footerHeight);
    auto controlsArea = footer.reduced (scaled (20), scaled (10));

    int knobWidth = scaled (80);

    // Focus knobs on the left
    auto knobArea = controlsArea.removeFromLeft (knobWidth * 3 + scaled (30));

    auto vocalKnob = knobArea.removeFromLeft (knobWidth);
    vocalsFocusLabel.setBounds (vocalKnob.removeFromTop (scaled (14)));
    vocalsFocusSlider.setBounds (vocalKnob.reduced (scaled (4), 0));

    knobArea.removeFromLeft (scaled (5));
    auto bassKnob = knobArea.removeFromLeft (knobWidth);
    bassCutoffLabel.setBounds (bassKnob.removeFromTop (scaled (14)));
    bassCutoffSlider.setBounds (bassKnob.reduced (scaled (4), 0));

    knobArea.removeFromLeft (scaled (5));
    auto drumKnob = knobArea.removeFromLeft (knobWidth);
    drumSensLabel.setBounds (drumKnob.removeFromTop (scaled (14)));
    drumSensSlider.setBounds (drumKnob.reduced (scaled (4), 0));

    // Quality selector
    auto qualityArea = controlsArea.removeFromLeft (scaled (100)).reduced (scaled (10), scaled (12));
    qualityLabel.setBounds (qualityArea.removeFromTop (scaled (14)));
    qualityArea.removeFromTop (scaled (4));
    qualityBox.setBounds (qualityArea.removeFromTop (scaled (28)));

    // Main content area
    bounds.reduce (margin, scaled (8));

    // Stem channels (left section) - proportional width
    int channelWidth = scaled (95);
    auto channelsArea = bounds.removeFromLeft (channelWidth * 4 + scaled (20));
    channelsArea.removeFromTop (scaled (5));

    for (size_t i = 0; i < 4; ++i)
    {
        stemChannels[i]->setBounds (channelsArea.removeFromLeft (channelWidth).reduced (scaled (2), 0));
    }

    // Master fader
    bounds.removeFromLeft (spacing);
    int masterWidth = scaled (75);
    auto masterArea = bounds.removeFromLeft (masterWidth).reduced (0, scaled (5));
    masterLabel.setBounds (masterArea.removeFromTop (scaled (22)));
    masterSlider.setBounds (masterArea);

    // Visualizer (remaining space - flexible)
    bounds.removeFromLeft (margin);
    visualizer.setBounds (bounds.reduced (0, scaled (5)));

    // Notify stem channels to update their internal scaling
    for (auto& channel : stemChannels)
        channel->repaint();
}

void StemperatorEditor::timerCallback()
{
    // Update stem levels from processor
    for (size_t i = 0; i < 4; ++i)
    {
        float level = processor.getStemLevel (static_cast<StemperatorProcessor::Stem> (i));
        stemChannels[i]->setLevel (level);
    }

    // Update visualizer
    visualizer.setStemLevels (
        processor.getStemLevel (StemperatorProcessor::Vocals),
        processor.getStemLevel (StemperatorProcessor::Drums),
        processor.getStemLevel (StemperatorProcessor::Bass),
        processor.getStemLevel (StemperatorProcessor::Other));
    visualizer.setInputLevel (processor.getInputLevel());

    // Update transport display in standalone mode
    updateTransportDisplay();
}
