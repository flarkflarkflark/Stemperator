#include "GPUNoiseReduction.h"
#include <juce_core/juce_core.h>

GPUNoiseReduction::GPUNoiseReduction()
{
    gpuEnabled = initializeGPU();

    if (gpuEnabled)
    {
        juce::Logger::writeToLog("GPU Noise Reduction: Initialized successfully");
        juce::Logger::writeToLog("GPU Backend: " + GPUBackend::getBackendName());
        auto deviceInfo = GPUBackend::getDeviceInfo();
        juce::Logger::writeToLog("GPU Device: " + deviceInfo.name + " (" + deviceInfo.vendor + ")");
    }
    else
    {
        juce::Logger::writeToLog("GPU Noise Reduction: Falling back to CPU");
    }
}

GPUNoiseReduction::~GPUNoiseReduction()
{
    shutdownGPU();
}

//==============================================================================
void GPUNoiseReduction::prepare(const juce::dsp::ProcessSpec& spec)
{
    sampleRate = spec.sampleRate;
    numChannels = spec.numChannels;

    // Initialize FFT parameters
    fftSize = 1 << fftOrder;
    hopSize = fftSize / 4; // 75% overlap

    // Allocate host buffers
    hostInputBuffer.resize(fftSize * 2 * static_cast<size_t>(numChannels));
    hostOutputBuffer.resize(fftSize * 2 * static_cast<size_t>(numChannels));
    overlapBuffer.setSize(static_cast<int>(numChannels), fftSize);
    overlapBuffer.clear();

    // Initialize noise profile
    noiseProfile.resize(fftSize / 2 + 1, 0.0f);
    profileCaptured = false;

    if (gpuEnabled)
    {
        // Create GPU FFT plan
        gpuFFT = std::make_unique<GPUBackend::GPUFFT>();
        if (!gpuFFT->createPlan(fftSize, static_cast<int>(numChannels)))
        {
            juce::Logger::writeToLog("GPU FFT plan creation failed, falling back to CPU");
            gpuEnabled = false;
            return;
        }

        // Allocate GPU buffers
        gpuInputBuffer = std::make_unique<GPUBackend::GPUBuffer>();
        gpuOutputBuffer = std::make_unique<GPUBackend::GPUBuffer>();
        gpuNoiseProfileBuffer = std::make_unique<GPUBackend::GPUBuffer>();

        size_t bufferSize = fftSize * 2 * numChannels * sizeof(float); // Complex data
        gpuInputBuffer->allocate(bufferSize);
        gpuOutputBuffer->allocate(bufferSize);
        gpuNoiseProfileBuffer->allocate((fftSize / 2 + 1) * sizeof(float));

        juce::Logger::writeToLog("GPU Noise Reduction: Buffers allocated (FFT size: " +
                                 juce::String(fftSize) + ")");
    }
}

void GPUNoiseReduction::reset()
{
    overlapBuffer.clear();
    isCapturingProfile = false;
    profileCaptureFrames = 0;
}

void GPUNoiseReduction::process(juce::dsp::ProcessContextReplacing<float>& context)
{
    auto& block = context.getOutputBlock();

    // Capture profile if requested
    if (isCapturingProfile)
    {
        if (gpuEnabled)
            captureProfileGPU(block);
        else
            processCPUFallback(block);
        return;
    }

    // Bypass if no profile or zero reduction
    if (!profileCaptured || reductionAmount <= 0.0f)
        return;

    // Process with GPU or CPU
    if (gpuEnabled)
        processGPU(block);
    else
        processCPUFallback(block);
}

//==============================================================================
void GPUNoiseReduction::captureProfile()
{
    isCapturingProfile = true;
    profileCaptureFrames = 0;
    std::fill(noiseProfile.begin(), noiseProfile.end(), 0.0f);
}

void GPUNoiseReduction::setReduction(float dB)
{
    reductionAmount = juce::jlimit(0.0f, 24.0f, dB);
    reductionLinear = juce::Decibels::decibelsToGain(reductionAmount);
}

void GPUNoiseReduction::setFFTSize(int size)
{
    // Find nearest power of 2
    fftOrder = static_cast<int>(std::log2(size));
    fftOrder = juce::jlimit(10, 15, fftOrder); // 1024 to 32768
    fftSize = 1 << fftOrder;
    hopSize = fftSize / 4;

    // Reinitialize if already prepared
    if (sampleRate > 0)
    {
        juce::dsp::ProcessSpec spec;
        spec.sampleRate = sampleRate;
        spec.numChannels = numChannels;
        spec.maximumBlockSize = static_cast<juce::uint32>(fftSize);
        prepare(spec);
    }
}

void GPUNoiseReduction::clearProfile()
{
    std::fill(noiseProfile.begin(), noiseProfile.end(), 0.0f);
    profileCaptured = false;
}

std::string GPUNoiseReduction::getGPUInfo() const
{
    if (!gpuEnabled)
        return "CPU (GPU unavailable)";

    auto deviceInfo = GPUBackend::getDeviceInfo();
    return deviceInfo.name + " (" + deviceInfo.backendName + ")";
}

//==============================================================================
void GPUNoiseReduction::processGPU(juce::dsp::AudioBlock<float>& block)
{
    // This is where the actual GPU processing happens
    // For now, implement CPU fallback - full GPU implementation requires
    // vendor-specific kernel code (CUDA/HIP/OpenCL)

    // TODO: Implement GPU kernels for spectral subtraction
    // This would involve:
    // 1. Upload audio data to GPU
    // 2. Execute FFT on GPU (via cuFFT/rocFFT/clFFT)
    // 3. Run spectral subtraction kernel
    // 4. Execute inverse FFT on GPU
    // 5. Download results back to CPU

    processCPUFallback(block);
}

void GPUNoiseReduction::processCPUFallback(juce::dsp::AudioBlock<float>& block)
{
    // Simple passthrough for now - full CPU implementation would mirror
    // the CPU NoiseReduction class
    // In production, this should call the existing NoiseReduction class
}

void GPUNoiseReduction::captureProfileGPU(const juce::dsp::AudioBlock<float>& block)
{
    // Simplified profile capture
    profileCaptureFrames++;

    if (profileCaptureFrames >= maxCaptureFrames)
    {
        profileCaptured = true;
        isCapturingProfile = false;

        if (gpuEnabled && gpuNoiseProfileBuffer)
        {
            // Upload noise profile to GPU
            uploadNoiseProfile();
        }

        juce::Logger::writeToLog("Noise profile captured (" + juce::String(profileCaptureFrames) + " frames)");
    }
}

void GPUNoiseReduction::performSpectralSubtractionGPU()
{
    // GPU kernel execution for spectral subtraction
    // This would be implemented with vendor-specific code
}

//==============================================================================
bool GPUNoiseReduction::initializeGPU()
{
    if (!GPUBackend::initialize())
    {
        juce::Logger::writeToLog("GPU Backend initialization failed");
        return false;
    }

    if (!GPUBackend::isAvailable())
    {
        juce::Logger::writeToLog("No GPU device available");
        return false;
    }

    return true;
}

void GPUNoiseReduction::shutdownGPU()
{
    if (gpuEnabled)
    {
        // Release GPU resources
        if (gpuFFT) gpuFFT->release();
        if (gpuInputBuffer) gpuInputBuffer->release();
        if (gpuOutputBuffer) gpuOutputBuffer->release();
        if (gpuNoiseProfileBuffer) gpuNoiseProfileBuffer->release();
        if (spectralSubtractionKernel) spectralSubtractionKernel->release();

        gpuFFT.reset();
        gpuInputBuffer.reset();
        gpuOutputBuffer.reset();
        gpuNoiseProfileBuffer.reset();
        spectralSubtractionKernel.reset();

        gpuEnabled = false;
    }
}

bool GPUNoiseReduction::uploadNoiseProfile()
{
    if (!gpuEnabled || !gpuNoiseProfileBuffer)
        return false;

    return gpuNoiseProfileBuffer->upload(noiseProfile.data(),
                                         noiseProfile.size() * sizeof(float));
}
