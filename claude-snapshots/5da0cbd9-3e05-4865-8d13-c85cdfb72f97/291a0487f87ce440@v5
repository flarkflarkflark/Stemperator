#pragma once

#include <JuceHeader.h>
#include "PremiumLookAndFeel.h"

/**
 * BatchEditorWindow - Reaper-style batch stem processor
 *
 * Features:
 * - File list (drag & drop or Add button)
 * - Output folder selection (default: next to source files)
 * - Model selection
 * - Progress display during processing
 */
class BatchEditorWindow : public juce::DocumentWindow,
                          public juce::FileDragAndDropTarget,
                          public juce::ListBoxModel
{
public:
    // Callback when user starts batch processing
    std::function<void (const juce::Array<juce::File>& files, const juce::String& modelName,
                        const juce::File& outputFolder)> onStartBatch;

    // Custom content component that paints its own background
    class ContentComponent : public juce::Component
    {
    public:
        void paint (juce::Graphics& g) override
        {
            g.fillAll (PremiumLookAndFeel::Colours::bgMid);
        }
    };

    BatchEditorWindow (const juce::String& modelName)
        : juce::DocumentWindow ("Batch Process",
                                PremiumLookAndFeel::Colours::bgDark,
                                juce::DocumentWindow::closeButton),
          currentModel (modelName)
    {
        setUsingNativeTitleBar (false);
        setTitleBarHeight (32);
        setResizable (true, true);
        setSize (550, 480);
        centreWithSize (getWidth(), getHeight());

        content = std::make_unique<ContentComponent>();
        setContentNonOwned (content.get(), true);  // Window doesn't own content, but resizes it

        // File list
        fileList = std::make_unique<juce::ListBox> ("Files", this);
        fileList->setColour (juce::ListBox::backgroundColourId, PremiumLookAndFeel::Colours::bgPanel);
        fileList->setColour (juce::ListBox::outlineColourId, PremiumLookAndFeel::Colours::accent.withAlpha (0.3f));
        fileList->setOutlineThickness (1);
        fileList->setRowHeight (24);
        fileList->setMultipleSelectionEnabled (true);
        content->addAndMakeVisible (fileList.get());

        // Input section label
        inputLabel = std::make_unique<juce::Label> ("", "Input Files:");
        inputLabel->setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textBright);
        inputLabel->setFont (juce::FontOptions (13.0f).withStyle ("Bold"));
        content->addAndMakeVisible (inputLabel.get());

        // Button row
        addButton = std::make_unique<juce::TextButton> ("Add Files...");
        addButton->onClick = [this] { addFiles(); };
        content->addAndMakeVisible (addButton.get());

        addFolderButton = std::make_unique<juce::TextButton> ("Add Folder...");
        addFolderButton->onClick = [this] { addFolder(); };
        content->addAndMakeVisible (addFolderButton.get());

        clearButton = std::make_unique<juce::TextButton> ("Clear");
        clearButton->onClick = [this] { files.clear(); updateUI(); };
        content->addAndMakeVisible (clearButton.get());

        removeButton = std::make_unique<juce::TextButton> ("Remove");
        removeButton->onClick = [this] { removeSelected(); };
        content->addAndMakeVisible (removeButton.get());

        // Output section
        outputLabel = std::make_unique<juce::Label> ("", "Output:");
        outputLabel->setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textBright);
        outputLabel->setFont (juce::FontOptions (13.0f).withStyle ("Bold"));
        content->addAndMakeVisible (outputLabel.get());

        outputModeCombo = std::make_unique<juce::ComboBox>();
        outputModeCombo->addItem ("Next to source files", 1);
        outputModeCombo->addItem ("Custom folder...", 2);
        outputModeCombo->setSelectedId (1);
        outputModeCombo->onChange = [this] { onOutputModeChanged(); };
        content->addAndMakeVisible (outputModeCombo.get());

        outputFolderLabel = std::make_unique<juce::Label> ("", "");
        outputFolderLabel->setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textDim);
        outputFolderLabel->setFont (juce::FontOptions (11.0f));
        content->addAndMakeVisible (outputFolderLabel.get());

        // Model selection
        modelLabel = std::make_unique<juce::Label> ("", "Model:");
        modelLabel->setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textBright);
        modelLabel->setFont (juce::FontOptions (13.0f).withStyle ("Bold"));
        content->addAndMakeVisible (modelLabel.get());

        modelCombo = std::make_unique<juce::ComboBox>();
        modelCombo->addItem ("htdemucs (4 stems)", 1);
        modelCombo->addItem ("htdemucs_6s (6 stems)", 2);
        modelCombo->setSelectedId (modelName == "htdemucs_6s" ? 2 : 1);
        modelCombo->onChange = [this] { currentModel = (modelCombo->getSelectedId() == 2) ? "htdemucs_6s" : "htdemucs"; };
        content->addAndMakeVisible (modelCombo.get());

        // Status / Progress
        statusLabel = std::make_unique<juce::Label> ("", "Drop audio files here or click 'Add Files'");
        statusLabel->setColour (juce::Label::textColourId, PremiumLookAndFeel::Colours::textDim);
        statusLabel->setFont (juce::FontOptions (12.0f));
        statusLabel->setJustificationType (juce::Justification::centred);
        content->addAndMakeVisible (statusLabel.get());

        progressBar = std::make_unique<juce::ProgressBar> (progress);
        progressBar->setColour (juce::ProgressBar::backgroundColourId, PremiumLookAndFeel::Colours::bgPanel);
        progressBar->setColour (juce::ProgressBar::foregroundColourId, PremiumLookAndFeel::Colours::active);
        progressBar->setVisible (false);
        content->addAndMakeVisible (progressBar.get());

        // Process button
        processButton = std::make_unique<juce::TextButton> ("Process All");
        processButton->setColour (juce::TextButton::buttonColourId, PremiumLookAndFeel::Colours::active.darker (0.2f));
        processButton->onClick = [this] { startProcessing(); };
        processButton->setEnabled (false);
        content->addAndMakeVisible (processButton.get());

        // Cancel button (hidden initially)
        cancelButton = std::make_unique<juce::TextButton> ("Cancel");
        cancelButton->setColour (juce::TextButton::buttonColourId, juce::Colours::darkred);
        cancelButton->onClick = [this] { requestCancel(); };
        cancelButton->setVisible (false);
        content->addAndMakeVisible (cancelButton.get());

        setVisible (true);
    }

    ~BatchEditorWindow() override = default;

    void closeButtonPressed() override
    {
        if (isProcessing)
        {
            requestCancel();
            return;
        }
        setVisible (false);
        juce::MessageManager::callAsync ([this]() { delete this; });
    }

    void resized() override
    {
        juce::DocumentWindow::resized();
        if (content == nullptr) return;

        auto b = content->getLocalBounds().reduced (12);

        // Bottom: Buttons row
        auto bottomRow = b.removeFromBottom (34);
        cancelButton->setBounds (bottomRow.removeFromRight (80));
        bottomRow.removeFromRight (8);
        processButton->setBounds (bottomRow.removeFromRight (100));

        b.removeFromBottom (10);

        // Progress bar
        progressBar->setBounds (b.removeFromBottom (18));
        b.removeFromBottom (6);

        // Status line
        statusLabel->setBounds (b.removeFromBottom (20));
        b.removeFromBottom (10);

        // Model selection row
        auto modelRow = b.removeFromBottom (26);
        modelLabel->setBounds (modelRow.removeFromLeft (50));
        modelCombo->setBounds (modelRow.removeFromLeft (160));
        b.removeFromBottom (8);

        // Output section
        auto outputRow = b.removeFromBottom (26);
        outputLabel->setBounds (outputRow.removeFromLeft (55));
        outputModeCombo->setBounds (outputRow.removeFromLeft (160));
        outputRow.removeFromLeft (8);
        outputFolderLabel->setBounds (outputRow);
        b.removeFromBottom (10);

        // Input label
        inputLabel->setBounds (b.removeFromTop (20));
        b.removeFromTop (4);

        // Button row (below file list label)
        auto buttonRow = b.removeFromBottom (28);
        addButton->setBounds (buttonRow.removeFromLeft (80));
        buttonRow.removeFromLeft (6);
        addFolderButton->setBounds (buttonRow.removeFromLeft (90));
        buttonRow.removeFromLeft (6);
        removeButton->setBounds (buttonRow.removeFromLeft (70));
        buttonRow.removeFromLeft (6);
        clearButton->setBounds (buttonRow.removeFromLeft (55));
        b.removeFromBottom (6);

        // File list takes the rest
        fileList->setBounds (b);
    }

    void paint (juce::Graphics& g) override
    {
        juce::DocumentWindow::paint (g);
    }

    // FileDragAndDropTarget
    bool isInterestedInFileDrag (const juce::StringArray& draggedFiles) override
    {
        if (isProcessing) return false;
        for (const auto& f : draggedFiles)
        {
            juce::File file (f);
            if (file.isDirectory() || isAudioFile (file))
                return true;
        }
        return false;
    }

    void filesDropped (const juce::StringArray& droppedFiles, int, int) override
    {
        if (isProcessing) return;
        for (const auto& f : droppedFiles)
        {
            juce::File file (f);
            if (file.isDirectory())
                addAudioFilesFromFolder (file);
            else if (isAudioFile (file))
                addFile (file);
        }
        updateUI();
    }

    // ListBoxModel
    int getNumRows() override { return files.size(); }

    void paintListBoxItem (int row, juce::Graphics& g, int width, int height, bool selected) override
    {
        if (row >= files.size()) return;

        if (selected)
            g.fillAll (PremiumLookAndFeel::Colours::accent.withAlpha (0.3f));
        else if (row % 2)
            g.fillAll (PremiumLookAndFeel::Colours::bgDark.withAlpha (0.15f));

        // Show processing status
        juce::Colour textColour = PremiumLookAndFeel::Colours::textBright;
        juce::String prefix = "";

        if (row < currentFileIndex)
        {
            textColour = PremiumLookAndFeel::Colours::active;  // Completed
            prefix = "\u2713 ";  // Checkmark
        }
        else if (row == currentFileIndex && isProcessing)
        {
            textColour = PremiumLookAndFeel::Colours::accent;  // Processing
            prefix = "\u25B6 ";  // Play symbol
        }

        g.setColour (textColour);
        g.setFont (juce::FontOptions (13.0f));
        g.drawText (prefix + files[row].getFileName(), 8, 0, width - 16, height, juce::Justification::centredLeft);
    }

    void deleteKeyPressed (int) override
    {
        if (!isProcessing) removeSelected();
    }

    void listBoxItemDoubleClicked (int row, const juce::MouseEvent&) override
    {
        if (isProcessing) return;
        if (row >= 0 && row < files.size())
        {
            files.remove (row);
            updateUI();
        }
    }

    // Progress update from external processing
    void setProgress (int fileIndex, int totalFiles, const juce::String& statusText)
    {
        juce::MessageManager::callAsync ([this, fileIndex, totalFiles, statusText]()
        {
            currentFileIndex = fileIndex;
            progress = (totalFiles > 0) ? (double) fileIndex / totalFiles : 0.0;
            statusLabel->setText (statusText, juce::dontSendNotification);
            fileList->repaint();
        });
    }

    void processingComplete (int successCount, int failCount)
    {
        juce::MessageManager::callAsync ([this, successCount, failCount]()
        {
            isProcessing = false;
            progress = 0.0;
            currentFileIndex = -1;
            progressBar->setVisible (false);
            processButton->setEnabled (true);
            processButton->setButtonText ("Process All");
            cancelButton->setVisible (false);
            addButton->setEnabled (true);
            addFolderButton->setEnabled (true);
            removeButton->setEnabled (true);
            clearButton->setEnabled (true);
            outputModeCombo->setEnabled (true);
            modelCombo->setEnabled (true);

            juce::String msg;
            if (failCount == 0)
                msg = "Completed: " + juce::String (successCount) + " file" + (successCount > 1 ? "s" : "") + " processed";
            else
                msg = "Done: " + juce::String (successCount) + " OK, " + juce::String (failCount) + " failed";
            statusLabel->setText (msg, juce::dontSendNotification);

            fileList->repaint();
        });
    }

    const juce::Array<juce::File>& getFiles() const { return files; }
    juce::String getModelName() const { return currentModel; }

    juce::File getOutputFolder() const
    {
        if (outputModeCombo->getSelectedId() == 2 && customOutputFolder.exists())
            return customOutputFolder;
        return juce::File();  // Empty = next to source
    }

private:
    juce::Array<juce::File> files;
    juce::String currentModel;
    juce::File customOutputFolder;
    double progress = 0.0;
    bool isProcessing = false;
    bool cancelRequested = false;
    int currentFileIndex = -1;

    std::unique_ptr<ContentComponent> content;
    std::unique_ptr<juce::ListBox> fileList;
    std::unique_ptr<juce::Label> inputLabel, outputLabel, modelLabel, statusLabel, outputFolderLabel;
    std::unique_ptr<juce::TextButton> addButton, addFolderButton, clearButton, removeButton;
    std::unique_ptr<juce::TextButton> processButton, cancelButton;
    std::unique_ptr<juce::ComboBox> outputModeCombo, modelCombo;
    std::unique_ptr<juce::ProgressBar> progressBar;
    std::unique_ptr<juce::FileChooser> fileChooser;

    bool isAudioFile (const juce::File& file)
    {
        auto ext = file.getFileExtension().toLowerCase();
        return ext == ".wav" || ext == ".mp3" || ext == ".flac" ||
               ext == ".aiff" || ext == ".aif" || ext == ".ogg" ||
               ext == ".m4a" || ext == ".wma" || ext == ".opus";
    }

    void addFile (const juce::File& file)
    {
        if (! files.contains (file))
            files.add (file);
    }

    void addAudioFilesFromFolder (const juce::File& folder)
    {
        for (const auto& entry : juce::RangedDirectoryIterator (folder, true, "*.wav;*.mp3;*.flac;*.aiff;*.aif;*.ogg;*.m4a;*.wma;*.opus"))
            if (entry.getFile().existsAsFile())
                addFile (entry.getFile());
    }

    void updateUI()
    {
        fileList->updateContent();
        if (files.isEmpty())
        {
            statusLabel->setText ("Drop audio files here or click 'Add Files'", juce::dontSendNotification);
            processButton->setEnabled (false);
        }
        else
        {
            // Calculate total size
            juce::int64 totalSize = 0;
            for (const auto& f : files)
                totalSize += f.getSize();

            juce::String info = juce::String (files.size()) + " file" + (files.size() > 1 ? "s" : "");
            if (totalSize > 1024 * 1024)
                info += " (" + juce::String::formatted ("%.1f MB", totalSize / (1024.0 * 1024.0)) + ")";

            statusLabel->setText (info + " ready to process", juce::dontSendNotification);
            processButton->setEnabled (true);
        }
    }

    void onOutputModeChanged()
    {
        if (outputModeCombo->getSelectedId() == 2)
        {
            // Custom folder - show file chooser
            fileChooser = std::make_unique<juce::FileChooser> (
                "Select Output Folder",
                juce::File::getSpecialLocation (juce::File::userMusicDirectory),
                "", true);

            fileChooser->launchAsync (
                juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
                [this] (const juce::FileChooser& fc)
                {
                    auto result = fc.getResult();
                    if (result.exists() && result.isDirectory())
                    {
                        customOutputFolder = result;
                        outputFolderLabel->setText (result.getFileName(), juce::dontSendNotification);
                    }
                    else
                    {
                        outputModeCombo->setSelectedId (1);
                        customOutputFolder = juce::File();
                        outputFolderLabel->setText ("", juce::dontSendNotification);
                    }
                });
        }
        else
        {
            customOutputFolder = juce::File();
            outputFolderLabel->setText ("", juce::dontSendNotification);
        }
    }

    void addFiles()
    {
        fileChooser = std::make_unique<juce::FileChooser> (
            "Select Audio Files",
            juce::File::getSpecialLocation (juce::File::userMusicDirectory),
            "*.wav;*.mp3;*.flac;*.aiff;*.aif;*.ogg;*.m4a;*.wma;*.opus", true);

        fileChooser->launchAsync (
            juce::FileBrowserComponent::openMode |
            juce::FileBrowserComponent::canSelectFiles |
            juce::FileBrowserComponent::canSelectMultipleItems,
            [this] (const juce::FileChooser& fc)
            {
                for (const auto& f : fc.getResults())
                    addFile (f);
                updateUI();
            });
    }

    void addFolder()
    {
        fileChooser = std::make_unique<juce::FileChooser> (
            "Select Folder with Audio Files",
            juce::File::getSpecialLocation (juce::File::userMusicDirectory),
            "", true);

        fileChooser->launchAsync (
            juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectDirectories,
            [this] (const juce::FileChooser& fc)
            {
                auto result = fc.getResult();
                if (result.exists() && result.isDirectory())
                {
                    addAudioFilesFromFolder (result);
                    updateUI();
                }
            });
    }

    void removeSelected()
    {
        auto selected = fileList->getSelectedRows();
        for (int i = selected.size() - 1; i >= 0; --i)
            if (selected[i] < files.size())
                files.remove (selected[i]);
        updateUI();
    }

    void startProcessing()
    {
        if (files.isEmpty() || onStartBatch == nullptr)
            return;

        isProcessing = true;
        cancelRequested = false;
        currentFileIndex = 0;
        progress = 0.0;

        // Disable UI during processing
        processButton->setEnabled (false);
        processButton->setButtonText ("Processing...");
        cancelButton->setVisible (true);
        addButton->setEnabled (false);
        addFolderButton->setEnabled (false);
        removeButton->setEnabled (false);
        clearButton->setEnabled (false);
        outputModeCombo->setEnabled (false);
        modelCombo->setEnabled (false);
        progressBar->setVisible (true);

        statusLabel->setText ("Starting...", juce::dontSendNotification);

        onStartBatch (files, currentModel, getOutputFolder());
    }

    void requestCancel()
    {
        cancelRequested = true;
        statusLabel->setText ("Cancelling...", juce::dontSendNotification);
    }

public:
    bool isCancelRequested() const { return cancelRequested; }

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (BatchEditorWindow)
};
